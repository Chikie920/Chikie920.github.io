<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
        <!--Valine-->
        <script src="/js/Valine.min.js"></script>
    <meta name="description" content="前言-本教程一方面是作为个人学习笔记另一方面也是本着一种助人为乐的态度写的，参考了C3程序员的视频同时也包含了我自己遇到问题时的经验而写成，我尽量将本笔记写的简洁并且易懂的同时囊括大部分的内容以节约大家的时间与耐心，没有时间观看视频的小伙伴们可以看我的笔记，要是觉得本笔记不适合的话推荐去观看原视频，这个老师讲的很好，内容也浅显易懂，希望大家能够支持他。如果本文章存在侵权行为，请联系我删除。如有错误">
<meta property="og:type" content="article">
<meta property="og:title" content="Socket网络编程">
<meta property="og:url" content="http://example.com/2021/01/23/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Chikie">
<meta property="og:description" content="前言-本教程一方面是作为个人学习笔记另一方面也是本着一种助人为乐的态度写的，参考了C3程序员的视频同时也包含了我自己遇到问题时的经验而写成，我尽量将本笔记写的简洁并且易懂的同时囊括大部分的内容以节约大家的时间与耐心，没有时间观看视频的小伙伴们可以看我的笔记，要是觉得本笔记不适合的话推荐去观看原视频，这个老师讲的很好，内容也浅显易懂，希望大家能够支持他。如果本文章存在侵权行为，请联系我删除。如有错误">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/2021_1_23_1.png">
<meta property="og:image" content="http://example.com/images/2021_1_23_2.png">
<meta property="og:image" content="http://example.com/images/2021_1_23_3.png">
<meta property="article:published_time" content="2021-01-23T13:37:02.000Z">
<meta property="article:modified_time" content="2021-04-26T07:24:25.341Z">
<meta property="article:author" content="Chikie">
<meta property="article:tag" content="Socket网络编程">
<meta property="article:tag" content="C">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/2021_1_23_1.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Socket网络编程</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/projects_url">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2021/10/24/PcNetwork-ChapterOne/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2020/12/13/%E5%85%B3%E4%BA%8E%E5%8D%9A%E4%B8%BB%E4%B8%8E%E6%9C%AC%E5%8D%9A%E5%AE%A2/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2021/01/23/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2021/01/23/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&text=Socket网络编程"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2021/01/23/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&title=Socket网络编程"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2021/01/23/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&is_video=false&description=Socket网络编程"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Socket网络编程&body=Check out this article: http://example.com/2021/01/23/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2021/01/23/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&title=Socket网络编程"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2021/01/23/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&title=Socket网络编程"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2021/01/23/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&title=Socket网络编程"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2021/01/23/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&title=Socket网络编程"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2021/01/23/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&name=Socket网络编程&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2021/01/23/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&t=Socket网络编程"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSOCKET"><span class="toc-number">2.</span> <span class="toc-text">什么是SOCKET</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SOCKET%E7%AE%80%E4%BB%8B%E4%B8%8E%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">SOCKET简介与简单的网络通信原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ETCP-IP%E7%9A%84C-S%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">基于TCP&#x2F;IP的C&#x2F;S通信模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">TCP&#x2F;IP协议的简单介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SOCKET%E9%80%9A%E4%BF%A1%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.2.</span> <span class="toc-text">SOCKET通信步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows%E7%BD%91%E7%BB%9C%E5%BA%93%E4%B8%8E%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">3.3.</span> <span class="toc-text">Windows网络库与头文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BD%91%E7%BB%9C%E5%BA%93-WSAStartup-%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.4.</span> <span class="toc-text">初始化网络库-WSAStartup()函数与返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VScode%E9%85%8D%E7%BD%AE"><span class="toc-number">3.5.</span> <span class="toc-text">VScode配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%A5%97%E6%8E%A5%E5%AD%97-socket-%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.6.</span> <span class="toc-text">创建套接字-socket()函数与返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E6%9C%AC%E5%9C%B0socket-bind-%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.7.</span> <span class="toc-text">绑定本地socket-bind()函数与返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E9%93%BE%E6%8E%A5-listen-%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.8.</span> <span class="toc-text">监听链接-listen()函数与返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%93%BE%E6%8E%A5-connect-%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.9.</span> <span class="toc-text">与服务端链接-connect()函数与返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%97%E9%93%BE%E6%8E%A5-accept-%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.10.</span> <span class="toc-text">接受链接-accept()函数与返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E4%BF%A1%E6%81%AF-recv-%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.11.</span> <span class="toc-text">接收信息-recv()函数与返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E4%BF%A1%E6%81%AF-send-%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.12.</span> <span class="toc-text">发送信息-send()函数与返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Server%E7%AB%AF%E5%AE%8C%E6%95%B4%E7%BC%96%E5%86%99"><span class="toc-number">3.13.</span> <span class="toc-text">Server端完整编写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Client%E7%AB%AF%E5%AE%8C%E6%95%B4%E7%BC%96%E5%86%99"><span class="toc-number">3.14.</span> <span class="toc-text">Client端完整编写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C"><span class="toc-number">3.15.</span> <span class="toc-text">运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">3.16.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-S%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">C&#x2F;S模型优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#select-%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">select()模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="toc-number">4.1.1.</span> <span class="toc-text">特点与原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93"><span class="toc-number">4.1.3.</span> <span class="toc-text">模型总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%85%B3%E9%97%AD%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.1.4.</span> <span class="toc-text">控制台关闭事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%80%89%E6%8B%A9%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">事件选择模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E4%BC%98%E5%8C%96%E4%B9%8B%E5%8F%98%E6%80%81%E7%82%B9%E5%87%BB"><span class="toc-number">4.2.2.</span> <span class="toc-text">有序优化之变态点击</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E9%80%89%E6%8B%A9%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">异步选择模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.1.</span> <span class="toc-text">窗口实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">4.3.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%8F%A0IO%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.4.</span> <span class="toc-text">重叠IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.4.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5"><span class="toc-number">4.4.2.</span> <span class="toc-text">事件通知</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.4.3.</span> <span class="toc-text">事件通知代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E4%BE%8B%E7%A8%8B"><span class="toc-number">4.4.4.</span> <span class="toc-text">完成例程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E4%BE%8B%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.4.5.</span> <span class="toc-text">完成例程代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E7%AB%AF%E5%8F%A3%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.5.</span> <span class="toc-text">完成端口模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E7%AB%AF%E5%8F%A3%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.5.1.</span> <span class="toc-text">完成端口代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%8C%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">完结</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Socket网络编程
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Chikie</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-01-23T13:37:02.000Z" itemprop="datePublished">2021-01-23</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/C/" rel="tag">C</a>, <a class="tag-link-link" href="/tags/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag">Socket网络编程</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>-本教程一方面是作为个人学习笔记另一方面也是本着一种助人为乐的态度写的，参考了<a target="_blank" rel="noopener" href="https://study.163.com/course/courseMain.htm?courseId=1006358018&share=1&shareId=1141882478">C3程序员</a>的视频同时也包含了我自己遇到问题时的经验而写成，我尽量将本笔记写的简洁并且易懂的同时囊括大部分的内容以节约大家的时间与耐心，没有时间观看视频的小伙伴们可以看我的笔记，要是觉得本笔记不适合的话推荐去观看原视频，这个老师讲的很好，内容也浅显易懂，希望大家能够支持他。如果本文章存在侵权行为，请联系我删除。如有错误，欢迎大家批评指正!</p>
<p>-作者使用Visual Studio Code搭配GCC编译器进行代码编写与运行，这里不介绍如何安装，如果你使用的其他环境，具体实践可能会与本文章的内容有所出入，请自行解决</p>
<p>-文章刚发布内容可能会不完善，后续将会慢慢补齐</p>
<p>-转载请注明链接，请尊重我的劳动成果！</p>
<h1 id="什么是SOCKET"><a href="#什么是SOCKET" class="headerlink" title="什么是SOCKET"></a>什么是SOCKET</h1><h2 id="SOCKET简介与简单的网络通信原理"><a href="#SOCKET简介与简单的网络通信原理" class="headerlink" title="SOCKET简介与简单的网络通信原理"></a>SOCKET简介与简单的网络通信原理</h2><p>SOCKET又称套接字，现代的网络通信就是通过SOCKET进行的，SOCKET编程也叫网络编程</p>
<p>Socket相当于一个电话，只需要知道另一个电话号码(另一端的信息)即可通信，我们并不需要了解手机是如何做成的，对与socket编程也一样，我们只需要了解简单的通信协议与函数即可编写出简单的通信模型出来，所以不要惧怕它。同时，我们需要善用<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/">MSDN</a>来学习有关函数的调用。</p>
<h1 id="基于TCP-IP的C-S通信模型"><a href="#基于TCP-IP的C-S通信模型" class="headerlink" title="基于TCP/IP的C/S通信模型"></a>基于TCP/IP的C/S通信模型</h1><h2 id="TCP-IP协议的简单介绍"><a href="#TCP-IP协议的简单介绍" class="headerlink" title="TCP/IP协议的简单介绍"></a>TCP/IP协议的简单介绍</h2><h2 id="SOCKET通信步骤"><a href="#SOCKET通信步骤" class="headerlink" title="SOCKET通信步骤"></a>SOCKET通信步骤</h2><h2 id="Windows网络库与头文件"><a href="#Windows网络库与头文件" class="headerlink" title="Windows网络库与头文件"></a>Windows网络库与头文件</h2><p><strong>WinSock2.h</strong>头文件，名称即为Windows下的socket简写，2指第二版的网络库(主版本)，我们使用新版的网络库不使用1版的，引入该头文件即可使用网络库的函数</p>
<p><strong>ws2_32.lib</strong>为windows网络库，需要有网络库并且成功初始化，WinSock2.h头文件内的函数才能成功的调用</p>
<p>头文件与库的名字都不区分大小写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="comment">//引入头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="comment">//引入网络库</span></span><br><span class="line"><span class="comment">////////   注：MinGW并不支持该语句，需要在VsCode的task文件内添加链接库         ////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">引入windows库的模板写法</span></span><br><span class="line"><span class="comment">#pragma comment(lib, &quot;库名字&quot;)</span></span><br><span class="line"><span class="comment">不用过多纠结</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="初始化网络库-WSAStartup-函数与返回值"><a href="#初始化网络库-WSAStartup-函数与返回值" class="headerlink" title="初始化网络库-WSAStartup()函数与返回值"></a>初始化网络库-WSAStartup()函数与返回值</h2><p><strong>函数介绍</strong></p>
<p>我们使用WSAStartup()函数来初始化网络库，以便网络函数能成功调用</p>
<p>W指windows </p>
<p>S指socket </p>
<p>A指Asynchronous异步，同步则阻塞，卡死，而异步则指多线程，同时的意思</p>
<p>Startup启动</p>
<p><strong>函数原型</strong></p>
<p>我们可以使用<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-wsastartup">MSDN</a>来查看相关函数，与其使用实例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WSAStartup</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  WORD      wVersionRequired,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPWSADATA lpWSAData</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数解析</strong></p>
<p>这个函数的返回值为int类型，有两个参数</p>
<p>一个为WORD类型，它并不是一个浮点型。变量名为wVersionRequired，变量名实际使用可以自定，指网络库的具体版本，目前最新为2.2版本(副版本)，对于详细版本可以在MSDN中搜索WSAStartup下翻查看</p>
<p>另一个为LPWSADATA类型，是一个指针类型，它指向WSADATA结构体，一般名称中有LP的基本都为指针类型</p>
<p><strong>函数返回值</strong></p>
<p>如果WSAStartup()调用成功则返回0，失败则返回其他值</p>
<p>若初始化网络库失败，则其他网络函数将无法正常使用</p>
<p><strong>使用函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">WORD WSVersion = (<span class="number">2</span>, <span class="number">2</span>);<span class="comment">//选择版本</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">官方提供这种方法来进行版本号的赋值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">WSADATA wsadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> wsas_return = WSAStartup(WSVersion, &amp;wsadata);</span><br><span class="line"><span class="keyword">if</span>(wsas_return != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始化网络库失败! 请检查网络库，或者重启电脑\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="VScode配置"><a href="#VScode配置" class="headerlink" title="VScode配置"></a>VScode配置</h2><p>需配置项目目录内的<code>.vscode</code>内的<code>tasks.json</code>文件内tasks-&gt;args，将库包含进工程，才能正常使用网络库函数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;args&quot;: [</span><br><span class="line">                &quot;-g&quot;,</span><br><span class="line">                &quot;$&#123;file&#125;&quot;,</span><br><span class="line">                &quot;-o&quot;,</span><br><span class="line">                &quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;,</span><br><span class="line">                <span class="string">&quot;-lws2_32&quot;</span></span><br><span class="line">            ],</span><br></pre></td></tr></table></figure>

<p>注意不要链接<code>ws32</code>库，这个库较老，无法正常使用事件选择模型的函数</p>
<h2 id="创建套接字-socket-函数与返回值"><a href="#创建套接字-socket-函数与返回值" class="headerlink" title="创建套接字-socket()函数与返回值"></a>创建套接字-socket()函数与返回值</h2><p><strong>函数介绍</strong></p>
<p>该函数用于创建进行通信的Socket</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SOCKET WSAAPI <span class="title">socket</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> af,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> type,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> protocol</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数解析</strong></p>
<p>第一个参数为地址的类型，填<strong>AF_INET</strong>，为使用IPV4地址为现在常用的地址类型，若填<strong>AF_INET6</strong>则为IPV6地址类型但尚未普及，可以选择不同的协议进行通信，但前提是知道对方的地址，并使用对应的地址类型，这里我们使用IPV4</p>
<p>第二个参数为套接字的类型，填<strong>SOCK_STREAM</strong>，即使用TCP进行通信</p>
<p>第三个为使用的协议类型，我们使用的是TCP/IP协议，所以填<strong>IPPROTO_TCP</strong></p>
<p>这里我们只是简单了解会使用即可，关于协议的解释，感兴趣的可以查找MSDN的Socket函数或者网上查阅大佬的文章</p>
<p><strong>函数返回值</strong></p>
<p>函数使用成功返回一个可用的Socket，否则返回<strong>INVALID_SOCKET</strong></p>
<p><strong>使用函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SOCKET server_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="keyword">if</span>(server_socket == INVALID_SOCKET)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建socket失败! 错误代码:&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> error = WSAGetLastError();<span class="comment">//可以使用该函数进行查看上个最近网络函数失败后的错误代码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,error);</span><br><span class="line">    WSACleanup();<span class="comment">//清理网络库</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//结束程序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">无法成功创建socket我们就无法通信，这是非常重要的环节之一，所以程序无法也没有必要再继续运行</span></span><br><span class="line"><span class="comment">在结束运行之前要关闭socket与清理网络库，由于这里创建socket失败所以我们无需关闭，只需要清理网络库即可</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="绑定本地socket-bind-函数与返回值"><a href="#绑定本地socket-bind-函数与返回值" class="headerlink" title="绑定本地socket-bind()函数与返回值"></a>绑定本地socket-bind()函数与返回值</h2><p><strong>函数介绍</strong></p>
<p>该函数用于给socket绑定具体地址与端口号用于通信</p>
<p><strong>地址与端口号的简单解释</strong></p>
<p>地址是唯一的，可以通过地址找到对应的计算机设备</p>
<p>计算机内的软件通过端口与外界通信，端口范围为0-65535，端口有我们所熟知的如22(SSH服务)、80(HTTP服务)等，我们也可以自己申请一个端口使用，后面的通信模型中我们会进行实践，一个软件可能只占用一个端口也可能是多个，端口号是唯一的，不能是多个软件拥有同一个端口，这样信息的传递是混乱的，同时计算机也不允许这样</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WSAAPI <span class="title">bind</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  SOCKET         s,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> sockaddr *name,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>            namelen</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数</strong></p>
<p>参数一为SOCKET类型，使用我们上面创建并配置好协议的<strong>server_socket</strong>，来进行端口号与地址的绑定</p>
<p>参数二为一个结构体指针，我们需要sockaddr类型的结构体内存放要绑定的地址与端口</p>
<p>参数三为结构体的大小，使用sizeof()函数得到</p>
<p><strong>sockaddr与sockaddr_in结构体的定义与选择</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">        ushort  sa_family;</span><br><span class="line">        <span class="keyword">char</span>    sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">        <span class="keyword">short</span>   sin_family;</span><br><span class="line">        u_short sin_port;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span></span><br><span class="line">        <span class="keyword">char</span>    sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同为IPV4协议使用的结构体，sockaddr第一个成员为地址协议，也就是我们创建socket时的协议类型(协议族)，指为AF_INET</p>
<p>第二个成员为一个数组，用于存放地址与端口，由于MSDN没有sockaddr成员二的存储方法，我们不能得知该以何种方式去赋值。</p>
<p>官方使用的是第二个结构体sockaddr_in，因为这两个结构体内存排布相同，我们在使用sockaddr_in进行配置后可以强转为sockaddr类型。</p>
<p>再让我们来看sockaddr_in，第一个成员与上一个相同，第二个成员可以看出是用来存放端口号的，第三个成员为一个in_addr类型的结构体，我在编译器内查看它的定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span> u_char  s_b1, s_b2, s_b3, s_b4; &#125; S_un_b;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span> u_short s_w1, s_w2; &#125; S_un_w;</span><br><span class="line">    u_long S_addr;</span><br><span class="line">  &#125; S_un;</span><br><span class="line">&#125; IN_ADDR, *PIN_ADDR, *LPIN_ADDR;</span><br></pre></td></tr></table></figure>

<p>结构体内为一个S_un联合，我们有三种方式去储存地址，这里为了方便我们使用第三种u_long型(无符号long型)进行存储。我们在进行本地通信模型时使用本机地址(<strong>127.0.0.1</strong>)进行数据通信，但是该地址并不是一个无符号long型，需要使用**inet_addr()**这个宏去将地址转换为u_long型。</p>
<p>这里可能会比较复杂，想了解更多可以去MSDN搜索sockaddr</p>
<p>第四个成员为sockaddr结构体的大小，同样使用sizeof()得出</p>
<p><strong>函数返回值</strong></p>
<p>成功返回0，失败返回SOCKET_ERROR宏，同样我们可以使用WSAGetLastError()来得到具体的错误代码</p>
<p><strong>函数使用</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">bind_info</span>;</span></span><br><span class="line">bind_info.sin_family = AF_INET;</span><br><span class="line">bind_info.sin_port = htons(<span class="number">2333</span>);<span class="comment">//下面解释该代码</span></span><br><span class="line">bind_info.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bind_return = bind(server_socket, (<span class="keyword">const</span> struct *)&amp;bind_info, <span class="keyword">sizeof</span>(bind_info));</span><br><span class="line"><span class="keyword">if</span>(bind_return != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ERROR! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">    closesocket(server_socket);<span class="comment">//关闭socket</span></span><br><span class="line">    WSACleanup();<span class="comment">//清理网络库</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    closesocket()为网络库函数，所以要先关闭socket再清理网络库</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">与socket函数相同，bind()函数也是重要的一环，当该函数没有正确的返回时，该程序也就失败了，没有必要再运行了</span></span><br><span class="line"><span class="comment">后面的一些函数使用例子也是如此，将不再赘述</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>使用本地地址并开启本地端口用于通信与htons宏的使用</strong></p>
<p>这里我们只经行本地通信，使用本机地址，在进行通信时，既作为服务端传递信息也作为客户端接收信息，当然，需要使用不同的程序</p>
<p>上面我们简单介绍过端口，其中0~1023为系统保留端口，是系统所占用的，我们无法申请使用</p>
<p>剩下的1024~65535为我们可以支配的，但是其中有些已经被我们所安装的软件所使用，我们不能再占用这些端口，比如我们想使用2333端口，那么如何去查看该端口是否被占用呢？</p>
<p><code>netstat -ano|findstr &quot;端口号&quot;</code>查看某个端口号是否被占用，如果没有任何信息则没有被占用</p>
<p><code>netstat -ano</code>查看所有被使用的端口号与信息</p>
<p>由于bind_info.sin_port为一个u_short类型(无符号short类型)，而我们输入的端口号为int类型，所以使用htons()函数经行转化，更加规范</p>
<h2 id="监听链接-listen-函数与返回值"><a href="#监听链接-listen-函数与返回值" class="headerlink" title="监听链接-listen()函数与返回值"></a>监听链接-listen()函数与返回值</h2><p><strong>函数介绍</strong></p>
<p>开启服务端对客户端的socket通信监听</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WSAAPI <span class="title">listen</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  SOCKET s,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>    backlog</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数</strong></p>
<p>WSAAP为调用约定，可以忽略，于我们无关</p>
<p>第一个参数为服务端socket，也就是上面我们创建于配置的server_socket</p>
<p>第二个参数为开始挂起客户端链接的最大长度，实际在通信时，一个服务端可能会接收到许多客户端的链接，由于服务端的性能有限，无法同时处理全部的链接，所以需要设置最大的处理个数，多出来的请求进行排队等待处理。我们可以自行设置个数，自己的电脑建议2~20个左右，也可以使用<code>SOMAXCONN</code>宏让系统根据自身性能自动设置。</p>
<p><strong>函数返回值</strong></p>
<p>成功返回0，失败返回SOCKET_ERROR</p>
<p><strong>函数使用</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> listen_return = listen(server_socket, SOMAXCONN);</span><br><span class="line"><span class="keyword">if</span>(listen_return != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ERROR! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">    closesocket(server_socket);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="与服务端链接-connect-函数与返回值"><a href="#与服务端链接-connect-函数与返回值" class="headerlink" title="与服务端链接-connect()函数与返回值"></a>与服务端链接-connect()函数与返回值</h2><p><strong>函数介绍</strong></p>
<p>该函数用于客户端与服务端链接</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WSAAPI <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  SOCKET         s,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> sockaddr *name,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>            namelen</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数</strong></p>
<p>参数一为服务端socket</p>
<p>参数二为服务端的协议与ip和端口信息</p>
<p>参数三为结构体大小</p>
<p><strong>函数返回值</strong></p>
<p>如果未发生错误，则 connect返回零。否则，它将返回SOCKET_ERROR</p>
<p><strong>函数使用</strong></p>
<p>与bind()相似</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_info</span>;</span></span><br><span class="line">server_info.sin_family = AF_INET;</span><br><span class="line">server_info.sin_port = htons(<span class="number">2333</span>);</span><br><span class="line">server_info.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> connect_return = connect(server_socket, (<span class="keyword">const</span> struct sockaddr *)&amp;server_info, <span class="keyword">sizeof</span>(server_info));</span><br><span class="line"><span class="keyword">if</span>(connect_return != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;与服务端链接错误! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">    closesocket(server_socket);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链接成功!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="接受链接-accept-函数与返回值"><a href="#接受链接-accept-函数与返回值" class="headerlink" title="接受链接-accept()函数与返回值"></a>接受链接-accept()函数与返回值</h2><p><strong>函数介绍</strong></p>
<p>创建客户端socket，储存客户端信息</p>
<p>这里要弄清楚，客户端与服务器进行通信使用储存服务端信息的socket，而服务端与客户端通信使用储存客户端信息的socket</p>
<p>相当于我们需要知道对方的电话号码才能通信</p>
<p>listen()通过监听客户端的链接，accept()将一个客户端信息绑定到一个socket上，多个客户端则调用多次</p>
<p>该函数是<strong>阻塞</strong>的，当没有客户端链接时会一直等待，相当于进入卡死状态，当客户端链接时继续运行</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SOCKET WSAAPI <span class="title">accept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  SOCKET   s,</span></span></span><br><span class="line"><span class="function"><span class="params">  sockaddr *addr,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>      *addrlen</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数</strong></p>
<p><strong>参数一</strong>为服务端socket即server_socket</p>
<p><strong>参数二</strong>为sockaddr类型的结构体指针，用于储存一个客户端信息，我们还是使用sockaddr_in类型更便捷</p>
<p><strong>参数三</strong>为结构体大小的整型指针</p>
<p>该函数是通过从服务端socket获取客户端信息进行储存，储存到我们所填的参数二与三的变量中。</p>
<p>所以参数二与三不需要给出具体值，实际上参数二我们也不清楚</p>
<p>参数二与三我们也可以不写，直接设置为NULL，选择不存储客户端的信息，当然返回的socket内是有储存的，但是下一次就被覆盖了</p>
<p>想储存可以使用链表，这里就不写了</p>
<p><strong>函数返回值</strong></p>
<p>成功则返回<strong>SOCKET</strong>类型的值，也就是一个socket，错误返回<strong>INVALID_SOCKET</strong></p>
<p><strong>函数使用</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SOCKET client_socket = accept(server_socket, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(client_socket == INVALID_SOCKET)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ERROR! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">    closesocket(server_socket);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;客户端链接成功!\n&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="接收信息-recv-函数与返回值"><a href="#接收信息-recv-函数与返回值" class="headerlink" title="接收信息-recv()函数与返回值"></a>接收信息-recv()函数与返回值</h2><p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WSAAPI <span class="title">recv</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  SOCKET s,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">char</span>   *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>    len,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>    flags</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数</strong></p>
<p>参数一为目标的socket</p>
<p>参数二为消息的储存空间(字符数组)，一般为1500(网络传输的最大单元)，不要超过它，超过了会分次发送</p>
<p>参数三为从缓冲区读取的字节数(读取后会被存储在数组中)</p>
<p>参数四为数据的读取方式，写0就行</p>
<p>当另一端发送消息时，数据由SOCKET底层协议进行储存在一个缓冲区中，而recv()则是从该缓冲区进行信息的读取放在数组中</p>
<p><strong>函数返回值</strong></p>
<p>未发生错误则返回接收到的字符数，如果正常关闭链接则返回0，错误则返回SOCKET_ERROR</p>
<p><strong>函数使用</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> rec_msg[<span class="number">1500</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> recv_return = recv(client_socket, rec_msg, <span class="number">1499</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(recv_return == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;客户端下线\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(recv_return &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, rec_msg);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ERROR! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="发送信息-send-函数与返回值"><a href="#发送信息-send-函数与返回值" class="headerlink" title="发送信息-send()函数与返回值"></a>发送信息-send()函数与返回值</h2><p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WSAAPI <span class="title">send</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  SOCKET     s,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> <span class="keyword">char</span> *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>        len,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>        flags</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数</strong></p>
<p>参数一为目标的socket</p>
<p>参数二为用来发送信息的字符串指针</p>
<p>参数三为字符串数组长度</p>
<p>参数四为发送的方式，同样我们填0就行</p>
<p><strong>函数返回值</strong></p>
<p>成功则返回发送的字节总数，否则返回SOCKET_ERROR</p>
<p><strong>函数使用</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> send_msg[<span class="number">1500</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> send_return = send(server_socket, send_msg, <span class="keyword">sizeof</span>(send_msg), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(send_return == SOCKET_ERROR)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ERROR! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Server端完整编写"><a href="#Server端完整编写" class="headerlink" title="Server端完整编写"></a>Server端完整编写</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WORD WSVersion = (<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">	WSADATA wsadata;</span><br><span class="line">    <span class="keyword">int</span> wsas_return = WSAStartup(WSVersion, &amp;wsadata);</span><br><span class="line">    <span class="keyword">if</span>(wsas_return != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;初始化网络库失败! 请检查网络库，或者重启电脑\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化网络库</span></span><br><span class="line">    </span><br><span class="line">    SOCKET server_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">	<span class="keyword">if</span>(server_socket == INVALID_SOCKET)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建socket失败! 错误代码:&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> error = WSAGetLastError();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,error);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建本地socket</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">bind_info</span>;</span></span><br><span class="line">    bind_info.sin_family = AF_INET;</span><br><span class="line">    bind_info.sin_port = htons(<span class="number">2333</span>);</span><br><span class="line">    bind_info.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> bind_return = bind(server_socket, (<span class="keyword">const</span> struct sockaddr *)&amp;bind_info, <span class="keyword">sizeof</span>(bind_info));</span><br><span class="line">    <span class="keyword">if</span>(bind_return != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ERROR! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">        closesocket(server_socket);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绑定本地ip与端口</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> listen_return = listen(server_socket, SOMAXCONN);</span><br><span class="line">    <span class="keyword">if</span>(listen_return != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ERROR! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">        closesocket(server_socket);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Listening...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//监听客户端链接</span></span><br><span class="line">    </span><br><span class="line">    SOCKET client_socket = accept(server_socket, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(client_socket == INVALID_SOCKET)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ERROR! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">        closesocket(server_socket);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;客户端链接成功!\n&quot;</span>);</span><br><span class="line">    <span class="comment">//创建客户端socket</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123; <span class="comment">//死循环使服务端能持续接收消息</span></span><br><span class="line">        <span class="keyword">char</span> rec_msg[<span class="number">1500</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span> send_msg[<span class="number">1500</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> recv_return = recv(client_socket, rec_msg, <span class="number">1499</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(recv_return == <span class="number">0</span>||recv_return == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端下线\n&quot;</span>);</span><br><span class="line">            closesocket(client_socket);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(recv_return &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, rec_msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//接收客户端信息</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,send_msg);</span><br><span class="line">        send(client_socket, send_msg, <span class="keyword">sizeof</span>(send_msg), <span class="number">0</span>);<span class="comment">//与客户端发消息</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    closesocket(client_socket);</span><br><span class="line">    closesocket(server_socket);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="comment">//关闭socket与清理网络库</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Client端完整编写"><a href="#Client端完整编写" class="headerlink" title="Client端完整编写"></a>Client端完整编写</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="comment">//socket头文件网络库</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WORD WSVersion = (<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    WSADATA wsadata;</span><br><span class="line">    <span class="keyword">int</span> wsas_return = WSAStartup(WSVersion, &amp;wsadata);</span><br><span class="line">    <span class="keyword">if</span>(wsas_return != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;初始化网络库失败! 请检查网络库，或者重启电脑\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化网络库</span></span><br><span class="line">    </span><br><span class="line">    SOCKET server_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span>(server_socket == INVALID_SOCKET)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建socket失败! 错误代码:&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> error = WSAGetLastError();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,error);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建服务端socket</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_info</span>;</span></span><br><span class="line">    server_info.sin_family = AF_INET;</span><br><span class="line">    server_info.sin_port = htons(<span class="number">2333</span>);</span><br><span class="line">    server_info.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> connect_return = connect(server_socket, (<span class="keyword">const</span> struct sockaddr *)&amp;server_info, <span class="keyword">sizeof</span>(server_info));</span><br><span class="line">    <span class="keyword">if</span>(connect_return != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;与服务端链接错误! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">        closesocket(server_socket);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;链接成功!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">char</span> recv_msg[<span class="number">1500</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">char</span> send_msg[<span class="number">1500</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,send_msg);</span><br><span class="line">            send(server_socket, send_msg, <span class="keyword">sizeof</span>(send_msg), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> recv_return = recv(server_socket, recv_msg, <span class="number">1499</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(recv_return == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;服务端中断!\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(recv_return == SOCKET_ERROR)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ERROR! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, recv_msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//与服务端链接</span></span><br><span class="line">    </span><br><span class="line">    closesocket(server_socket);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="comment">//关闭socket与清理网络库</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><img src="/images/2021_1_23_1.png"></p>
<p><img src="/images/2021_1_23_2.png"></p>
<p><img src="/images/2021_1_23_3.png"></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果你试着写出了C/S模型，你会发现我们上面所写的模型server端不能与多个client端通信，并且当与一个client端通信时只能以一种“回合制”模式进行。因为listen()与accept()函数只接收了一个client_socket，只能与一个client通信，而我们的recv()函数是阻塞的，当没有另一端的信息时会一直等待，无法执行后续的代码(accept函数也是如此)。这样的通讯无疑是没有实际用处的。</p>
<h1 id="C-S模型优化"><a href="#C-S模型优化" class="headerlink" title="C/S模型优化"></a>C/S模型优化</h1><h2 id="select-模型"><a href="#select-模型" class="headerlink" title="select()模型"></a>select()模型</h2><h3 id="特点与原理"><a href="#特点与原理" class="headerlink" title="特点与原理"></a>特点与原理</h3><p><strong>特点</strong>：select模型用于服务端，客户端代码不变，解决基本C/S模型中，accept()与recv()函数傻等的问题(select本身是执行阻塞的)，实现与多个客户端链接与多个客户端同时通信。</p>
<p><strong>原理</strong>：将所有SOCKET装如一个数组，通过select函数遍历数组，将所有有响应的SOCKET返回。<strong>当有客户端链接</strong>时<strong>服务端监听套接字</strong>会有响应，我们调用accept函数处理；<strong>当有响应的SOCKET为客户端的</strong>，则说明有客户端通信，调用send或recv函数。</p>
<p><strong>fd_set结构体</strong></p>
<p>为什么使用它–因为select函数的参数需要该结构体，所以我们使用它的成员来储存SOCKET</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">fd_set</span> &#123;</span></span><br><span class="line">  u_int  fd_count;</span><br><span class="line">  SOCKET fd_array[FD_SETSIZE];</span><br><span class="line">&#125; fd_set, FD_SET, *PFD_SET, *LPFD_SET;</span><br></pre></td></tr></table></figure>

<p><strong>成员一</strong>为无符号整型，用来记录集合中有响应的SOCKET数量</p>
<p><strong>成员二</strong>为储存SOCKET的集合，<code>FD_SETSIZE</code>为宏，值为64，我们可以通过在套接字头文件前使用 <code>define</code>重新定义大小</p>
<p><strong>四个操作fd_set结构体的参数宏</strong></p>
<p><code>FD_ZERO</code>：参数为fd_set结构体地址，将结构体内数组初始化(其实就是将fd_count初始化为0)</p>
<p>示例： <code>FD_ZERO(&amp;AllSockets);</code></p>
<p><code>FD_SET</code>：向集合中添加一个SOCKET</p>
<p>示例：<code>FD_SET(Socket, &amp;AllSockets);</code></p>
<p><code>FD_CLR</code>：集合中删除指定SOCKET</p>
<p>示例：<code>FD_CLR(Socket, &amp;AllSockets);</code></p>
<p><strong>注意：</strong>在从集合中删除SOCKET后要记得释放掉SOCKET，不然会<strong>内存泄漏</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SOCKET Temp_Socket;</span><br><span class="line">Temp_Socket = AllSockets.fd_array[n];</span><br><span class="line">FD_CLR(AllSockets.fd_array[n], &amp;AllSockets);</span><br><span class="line">closesocket(Temp_Socket);</span><br><span class="line"><span class="comment">//现在看不懂没关系，后续学习中会明白</span></span><br></pre></td></tr></table></figure>

<p><code>FD_ISSET</code>：判断SOCKET是否在集合中，不在返回0，在返回非0</p>
<p>示例：<code>FD_ISSET(Socket, &amp;AllSockets);</code></p>
<p><strong>select函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WSAAPI <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>           nfds,</span></span></span><br><span class="line"><span class="function"><span class="params">  fd_set        *readfds,</span></span></span><br><span class="line"><span class="function"><span class="params">  fd_set        *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">  fd_set        *exceptfds,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> timeval *timeout</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数一</strong>仅用作兼容，我们不需要管它，填0即可</p>
<p><strong>参数二</strong>传入fd_set结构体，select函数将检查是否有可读SOCKET，并返回</p>
<p><strong>原理</strong>：我们将含SOCKET集合的结构体作为参数，select将其投放给系统，系统将有响应的SOCKET返回到原数组，只剩下有响应的SOCKET，然后我们可以根据SOCKET的不同，进行不同处理</p>
<p><strong>参数三</strong>传入类型相同，用于检查是否有可写SOCKET，系统将可以被发送消息的SOCKET返回到原数组，一般正常链接了我们随时可以发送消息，而不是需要等到有响应才可以发送，所以我们用的不是特别多</p>
<p><strong>参数四</strong>传入类型相同，用于检查 SOCKET的异常错误，返回有异常的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getsockopt(socket, SOL_SOCKET, SO_ERROR, buf, buflen); <span class="comment">//得到错误码</span></span><br></pre></td></tr></table></figure>

<p><strong>参数五</strong>为最大等待时间，select为执行阻塞，需要设置等待时间，当客户端SOCKET集合无响应时会等待</p>
<p>两个都赋值0，则此时select为非阻塞，无函数等待时间，两个都赋值NULL则完全阻塞成为傻等</p>
<p><strong>timeval结构体</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span> tv_sec;</span><br><span class="line">  <span class="keyword">long</span> tv_usec;</span><br><span class="line">&#125; TIMEVAL, *PTIMEVAL, *LPTIMEVAL;</span><br></pre></td></tr></table></figure>

<p><strong>成员一</strong>以秒单位</p>
<p><strong>成员二</strong>以毫秒为单位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">secondtime</span>;</span></span><br><span class="line">secondtime.tv_sec = <span class="number">3</span>;</span><br><span class="line">secondtime.tv_usec = <span class="number">4</span>;</span><br><span class="line"><span class="comment">//等待时间为3秒4微秒</span></span><br></pre></td></tr></table></figure>



<p><strong>select函数返回值</strong></p>
<ul>
<li><code>0</code>，客户端SOCKET无反应，我们continue就行</li>
<li><code>大于0</code>，有客户端响应</li>
<li><code>SOCKET_ERROR</code>，错误，使用 <code>WSAGetLastError()</code>函数得到错误代码</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上方代码与C/S模型相同</span></span><br><span class="line">fd_set AllSockets;</span><br><span class="line">FD_ZERO(&amp;AllSockets); <span class="comment">//创建并初始化结构体</span></span><br><span class="line">FD_SET(ServerSocket, &amp;AllSockets); <span class="comment">//将服务端监听SOCKET放入数组</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">seconds</span>;</span></span><br><span class="line">seconds.tv_sec = <span class="number">3</span>;</span><br><span class="line">seconds.tv_usec = <span class="number">0</span>; <span class="comment">//设置select函数等待时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	fd_set ReadSockets = AllSockets; <span class="comment">//因为select函数会改变传入的结构体，不能改变原来的SOCKET集合</span></span><br><span class="line">        <span class="keyword">int</span> select_return = select(<span class="number">0</span>, &amp;ReadSockets, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;seconds);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(select_return == <span class="number">0</span>)&#123; <span class="comment">//无客户端响应</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(select_return &gt; <span class="number">0</span>)&#123; <span class="comment">//有客户端响应</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; ReadSockets.fd_count; ++n)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(ReadSockets.fd_array[n] == server_socket)&#123; <span class="comment">//检查是否为服务端SOCKET</span></span><br><span class="line">                    SOCKET SocketClient = accept(server_socket, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">//接受客户端链接</span></span><br><span class="line">                    <span class="keyword">if</span>(SocketClient == INVALID_SOCKET)&#123; <span class="comment">//错误处理</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    FD_SET(SocketClient, &amp;AllSockets); <span class="comment">//将建立连接的客户端SOCKET装入结构体数组成员中，用于后续的响应监测</span></span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">char</span> Msg[<span class="number">1500</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="keyword">int</span> recv_return = recv(ReadSockets.fd_array[n], Msg, <span class="number">1499</span>, <span class="number">0</span>); <span class="comment">//接收客户端消息</span></span><br><span class="line">                    <span class="keyword">if</span>(recv_return == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;客户端下线\n&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(recv_return &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, Msg);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;ERROR 客户端强制下线\n&quot;</span>);</span><br><span class="line">                        SOCKET socketTemp = ReadSockets.fd_array[n];</span><br><span class="line">                        FD_CLR(ReadSockets.fd_array[n],&amp;AllSockets); <span class="comment">//移除下线SOCKET</span></span><br><span class="line">                        closesocket(socketTemp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="comment">// else</span></span><br><span class="line">                </span><br><span class="line">            &#125; <span class="comment">// for</span></span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 发生错误</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;发生错误! 错误代码: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// while</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; AllSockets.fd_count; ++n)&#123;</span><br><span class="line">        SOCKET socketTemp = AllSockets.fd_array[n];</span><br><span class="line">        closesocket(socketTemp);</span><br><span class="line">    &#125; <span class="comment">//最后千万别忘了释放SOCKET集合，不然会内存泄漏</span></span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="comment">//清理网络库</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<p><strong>关于一些代码的解释</strong></p>
<p>刚开始定义 <code>fd_set</code>结构体，我们装入监听客户端链接的服务端SOCKET，并将结构体作为参数传入<code>select</code>函数，<strong>若有客户端链接时，服务端监听的SOCKET会有响应</strong>，被返回出来，此时<code>fd_set</code>结构体的<code>fd_count</code>成员值为<code>1</code>，表明有一个有响应的SOCKET。此时我们可以使用<code>accept</code>函数进行与客户端的链接并创建存储客户端信息的SOCKET，并将其装入原SOCKET集合中，以此来用<code>select</code>监听其是否会有后续的响应，若有响应则表明有该客户端发来的消息，我们使用<code>recv</code>来接收。</p>
<p>若客户端下线则我们需要将其从原SOCKET集合中移除，并使用<code>closesocket()</code>释放</p>
<p><strong>关于参数三</strong>，只要与客户端链接了，那该客户端SOCKET就是可写的，不一定需要该参数决定。如果我们向参数三传入AllSockets的副本，其中的ServerSocket不会对返回的数组成员造成影响，并且，只要有客户端链接成功，参数三返就一直是有响应的，select函数的返回值就<strong>永远大于0</strong></p>
<p><strong>参数四</strong> 用于处理异常SOCKET，异常条件较苛刻，我们一般不会遇到所以用不上</p>
<h3 id="模型总结"><a href="#模型总结" class="headerlink" title="模型总结"></a>模型总结</h3><ol>
<li>创建SOCKET集合</li>
<li>select()遍历</li>
<li>处理<ol>
<li>返回0 - 无响应，继续遍历</li>
<li>大于0 - 分类处理</li>
<li>SOCKET_ERROR</li>
</ol>
</li>
</ol>
<p>select函数是阻塞的</p>
<ol>
<li>不等待 - 执行阻塞（原因：select函数遍历SOCKET集合需要时间）</li>
<li>半等待 - 执行阻塞+软阻塞</li>
<li>全等待 - 执行阻塞+硬阻塞（傻等）</li>
</ol>
<h3 id="控制台关闭事件"><a href="#控制台关闭事件" class="headerlink" title="控制台关闭事件"></a>控制台关闭事件</h3><p>当我们直接关闭Server程序窗口时，很可能不会释放所有SOCKET与关闭网络库，我们可以请求操作系统监视我们的窗口，当我们点<code>×</code>关闭窗口时，系统可以调用我们的函数释放数组与关闭网络库。(钩子事件)</p>
<p><strong>SetConsoleCtrlHandler 函数</strong></p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">SetConsoleCtrlHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ PHANDLER_ROUTINE HandlerRoutine,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     BOOL             Add</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<p><strong>函数使用</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetConsoleCtrlHandler(function_name, TRUE);</span><br></pre></td></tr></table></figure>

<p><strong>参数一</strong>为我们需要调用的自定义的函数名-<strong>回调函数名</strong>，回调函数需要在该函数使用前定义</p>
<p><strong>参数二</strong>可填<strong>TRUE</strong>和<strong>FALSE</strong>，当收到事件的时候，<strong>HandlerRoutine-回调函数</strong>可以选择处理，或者简单的忽略。如果回调函数选择忽略，函数返回FALSE，系统将处理下一个钩子程序。如果处理消息，程序在处理完消息后应该返回TRUE。即填TRUE会调用我们的函数，FALSE不会</p>
<p><strong>HandlerRoutine 回调函数</strong></p>
<p>回调函数为被系统调用的函数</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">HandlerRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ DWORD dwCtrlType <span class="comment">// _In_ 只起说明作用表明为传入，填入参数时可去掉</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<p><strong>实际使用演示</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">fd_set AllSockets; <span class="comment">//定义为全局对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Console_Shutdown</span><span class="params">(DWORD dwCtrlType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(dwCtrlType)&#123;</span><br><span class="line">        <span class="keyword">case</span> CTRL_CLOSE_EVENT: </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; AllSockets.fd_count; ++n)&#123;</span><br><span class="line">                SOCKET socketTemp = AllSockets.fd_array[n];</span><br><span class="line">                closesocket(socketTemp);</span><br><span class="line">            &#125;</span><br><span class="line">            WSACleanup();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        	<span class="comment">//关闭窗口时，释放SOCKET与清理网络库处理</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125; <span class="comment">//回调函数定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SetConsoleCtrlHandler(Console_Shutdown, TRUE); <span class="comment">//系统监视</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="事件选择模型"><a href="#事件选择模型" class="headerlink" title="事件选择模型"></a>事件选择模型</h2><p><strong>Windows消息机制与事件机制</strong></p>
<p><strong>消息机制</strong>：核心 - 消息队列（按操作顺序先入先出队列），用户操作产生消息，由计算机放入队列，然后被我们依次处理。消息队列由计算机创建与维护，我们无法干涉和改变，只能做调用，根据消息做分类处理。异步选择模型基于消息机制。</p>
<p><strong>事件机制</strong>：核心 - 事件集合（无顺序），事件由我们自己调用API创建，需要多少创建多少，给每个操作绑定事件（相当于给每个事件绑定ID），每个事件的检测顺序由程序员决定（事件集合由我们自己创建，我们可以将事件装入数组等），并将事件投递给系统监视，系统会根据我们创建集合的事件顺序依次检测，不能无限创建，太多系统处理不来。</p>
<p><strong>事件选择模型的处理逻辑</strong></p>
<p>整体逻辑与select模型差不多，核心函数为**<code>WSAEventSelect()</code>**</p>
<ol>
<li>创建一个事件对象 <strong><code>WSACreateEvent()</code></strong></li>
<li>给每个事件对象绑定SOCKET以及对应操作 <code>accept、read、close等</code>并投递给操作系统，然后就不用管了，系统自动监管 <strong><code>WSAEventSelect()</code></strong>-绑定加投递功能</li>
<li>查看事件是否有信号 <strong><code>WSAWaitForMultipleEvents()</code></strong></li>
<li>有信号就分类处理 <strong><code>WSAEnumNetworkEvents()</code></strong></li>
</ol>
<p><strong>函数介绍</strong></p>
<p><strong>WSACreateEvent函数</strong></p>
<p><strong>函数语法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WSAEVENT WSAAPI <span class="title">WSACreateEvent</span><span class="params">()</span></span>; <span class="comment">//WSAAPI为调用约定，与我们基本没关系，去掉没影响</span></span><br></pre></td></tr></table></figure>



<p><strong>无参数</strong></p>
<p><strong>返回值</strong></p>
<p>没有错误返回事件<strong>对象句柄</strong>（相当于ID，每个事件独立），否则返回值为<strong>WSA_INVALID_EVENT</strong>，获取错误信息使用 <code>WSAGetLastError()</code></p>
<p>句柄（事件对象）是一种<strong>内核对象</strong>，由操作系统在内核申请、访问，我们不能定位其内容也无法修改；不用了要用函数释放，不然会造成内核内存泄漏，与内存泄漏不同，内存泄漏只需关闭程序即可回收，而内核内存泄漏只能重启解决。Socket就是一种内核对象。</p>
<p><strong>WSACloseEvent函数</strong></p>
<p><strong>函数原型</strong></p>
<p>用于关闭事件对象，不用就要释放</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WSAAPI <span class="title">WSACloseEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  WSAEVENT hEvent</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<p><strong>参数介绍</strong></p>
<p>需要关闭的事件对象名</p>
<p><strong>返回值</strong></p>
<p>成功为TRUE，失败为FALSE，获取错误信息使用 <code>WSAGetLastError()</code></p>
<p><strong>WSAEventSelect函数</strong></p>
<p>给事件绑定SOCKET与操作码（用户操作事件），并投递给操作系统</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WSAAPI <span class="title">WSAEventSelect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  SOCKET   s,</span></span></span><br><span class="line"><span class="function"><span class="params">  WSAEVENT hEventObject,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">long</span>     lNetworkEvents</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<p><strong>参数介绍</strong></p>
<p><strong>参数一</strong>为被绑定的SOCKET，每个SOCKET都要被绑定事件</p>
<p><strong>参数二</strong>为事件对象，与参一绑定</p>
<p><strong>参数三</strong>为具体事件 <code>FD_ACCEPT等</code>，可以使用<strong>位或</strong>进行多个事件绑定，当有事件发生时，会产生信号</p>
<table>
<thead>
<tr>
<th><strong>FD_ACCEPT</strong></th>
<th>与服务器SOCKET绑定，有客户端链接时有响应</th>
</tr>
</thead>
<tbody><tr>
<td><strong>FD_READ</strong></td>
<td><strong>与客户端SOCKET绑定，有客户端消息时有响应</strong></td>
</tr>
<tr>
<td><strong>FD_CLOSE</strong></td>
<td><strong>与客户端SOCKET绑定，有客户端下线(强制或正常)时有响应</strong></td>
</tr>
<tr>
<td><strong>FD_WRITE</strong></td>
<td><strong>与客户端SOCKET绑定，在accept后立即产生该信号，客户端链接成功即可发消息</strong></td>
</tr>
<tr>
<td><strong>FD_CONNECT</strong></td>
<td><strong>用于客户端，服务器端用不到，给服务器SOCKET绑定</strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td><strong>取消事件监视</strong></td>
</tr>
<tr>
<td><strong>FD_OOB</strong></td>
<td><strong>一般不使用</strong></td>
</tr>
<tr>
<td><strong>FD_QOS</strong></td>
<td><strong>套接字服务质量变化通知</strong></td>
</tr>
<tr>
<td><strong>FD_GROUP_QOS</strong></td>
<td><strong>没有具体意义，保留词</strong></td>
</tr>
</tbody></table>
<p>给原有事件对象再次绑定事件会覆盖原有事件</p>
<p><strong>返回值</strong></p>
<p>成功返回0，失败返回<code>SOCKET_ERROR</code></p>
<p><strong>WSAWaitForMultipleEvents函数</strong></p>
<p>询问发生信号的事件</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WSAAPI <span class="title">WSAWaitForMultipleEvents</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD          cEvents,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> WSAEVENT *lphEvents,</span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL           fWaitAll,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD          dwTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL           fAlertable</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<p><code>DWORD</code>为无符号长整型</p>
<p><strong>参数介绍</strong></p>
<p><strong>参数一</strong>为事件个数</p>
<p><strong>参数二</strong>为事件数组首地址</p>
<p><strong>参数三</strong>为事件等待方式，TRUE-阻塞，等到所有事件都有信号才返回，FALSE，任何一个有信号立即返回</p>
<p><strong>参数四</strong>为超时间隔，以毫秒为单位，一直等待宏 <strong>WSA_INFINITE</strong></p>
<p><strong>参数五</strong>为选择模型，TRUE为<strong>重叠IO模型</strong>使用的，FALSE为<strong>事件选择模型</strong>使用</p>
<p><strong>返回值</strong></p>
<p>参数三为TRUE返回，返回值指示已发出所有指定的事件对象的信号</p>
<p>参数三为FALSE返回，返回值减去<strong>WSA_WAIT_EVENT_0</strong>表示满足等待信号的事件对象的数组索引（下标）</p>
<p>参数五为TRUE返回，<strong>WSA_WAIT_IO_COMPLETION</strong></p>
<p>超时返回，<strong>WSA_WAIT_TIMEOUT</strong>，<code>continue</code>即可</p>
<p>失败返回，<strong>WSA_WAIT_FAILED</strong></p>
<p><strong>WSAEnumNetworkEvents函数</strong></p>
<p>列举事件，获取事件类型，并将信号重置</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WSAAPI <span class="title">WSAEnumNetworkEvents</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  SOCKET             s,</span></span></span><br><span class="line"><span class="function"><span class="params">  WSAEVENT           hEventObject,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPWSANETWORKEVENTS lpNetworkEvents</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<p><strong>参数介绍</strong></p>
<p><strong>参数一</strong>为SOCKET</p>
<p><strong>参数二</strong>为对应事件</p>
<p><strong>参数三</strong>装触发类型的事件，是一个结构体指针 <code>WSANETWORKEVENTS</code></p>
<p><strong>结构体原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WSANETWORKEVENTS</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span> lNetworkEvents;</span><br><span class="line">  <span class="keyword">int</span>  iErrorCode[FD_MAX_EVENTS];</span><br><span class="line">&#125; WSANETWORKEVENTS, *LPWSANETWORKEVENTS;</span><br></pre></td></tr></table></figure>

<p>结构体成员一为<strong>指示发生了哪些FD_XXX网络事件</strong></p>
<p>成员二为<strong>错误码数组</strong>，包含与对应于事件的比特中的位置的数组索引相关联的任何错误代码<strong>lNetworkEvents</strong>。诸如FD_READ_BIT和FD_WRITE_BIT之类的标识符可用于索引<strong>iErrorCode</strong>数组</p>
<p><strong>返回值</strong></p>
<p>成功返回0，失败返回 <code>SOCKET_ERROR</code></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>开始监听及以前代码与基本C\S模型相同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="comment">//引用头文件与网络库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">event_socket_set</span> &#123;</span></span><br><span class="line">    SOCKET socket_all[<span class="number">64</span>];</span><br><span class="line">    WSAEVENT event_all[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125; event_socket_set;</span><br><span class="line"></span><br><span class="line">fd_set AllSockets;</span><br><span class="line"><span class="comment">//创建存放SOCKET与事件对象的容器，因为我们需要对每个SOCKET绑定相应的事件</span></span><br><span class="line">event_socket_set es_set = &#123;&#123;<span class="number">0</span>&#125;, &#123;<span class="number">0</span>&#125;, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">Console_Shutdown</span><span class="params">(DWORD dwCtrlType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(dwCtrlType)&#123;</span><br><span class="line">        <span class="keyword">case</span> CTRL_CLOSE_EVENT: </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; es_set.count; ++n)&#123;</span><br><span class="line">            closesocket(es_set.socket_all[n]);</span><br><span class="line">            WSACloseEvent(es_set.event_all[n]);</span><br><span class="line">        &#125;</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    SetConsoleCtrlHandler(Console_Shutdown, TRUE);</span><br><span class="line"></span><br><span class="line">    WORD WSVersion = (<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">	WSADATA wsadata;</span><br><span class="line">    <span class="keyword">int</span> wsas_return = WSAStartup(WSVersion, &amp;wsadata);</span><br><span class="line">    <span class="keyword">if</span>(wsas_return != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;初始化网络库失败! 请检查网络库，或者重启电脑\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化网络库</span></span><br><span class="line">    </span><br><span class="line">    SOCKET server_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">	<span class="keyword">if</span>(server_socket == INVALID_SOCKET)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建socket失败! 错误代码:&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> error = WSAGetLastError();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,error);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建本地socket</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">bind_info</span>;</span></span><br><span class="line">    bind_info.sin_family = AF_INET;</span><br><span class="line">    bind_info.sin_port = htons(<span class="number">2333</span>);</span><br><span class="line">    bind_info.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> bind_return = bind(server_socket, (<span class="keyword">const</span> struct sockaddr *)&amp;bind_info, <span class="keyword">sizeof</span>(bind_info));</span><br><span class="line">    <span class="keyword">if</span>(bind_return != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;BIND ERROR! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">        closesocket(server_socket);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绑定本地ip与端口</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> listen_return = listen(server_socket, SOMAXCONN);</span><br><span class="line">    <span class="keyword">if</span>(listen_return != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LISETEN ERROR! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">        closesocket(server_socket);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Listening...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//监听客户端链接</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建事件</span></span><br><span class="line">    WSAEVENT EventServer = WSACreateEvent();</span><br><span class="line">    <span class="comment">//返回值处理</span></span><br><span class="line">    <span class="keyword">if</span>(EventServer == WSA_INVALID_EVENT)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CREATE EVENT ERROR! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">        closesocket(server_socket);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//事件绑定与投递</span></span><br><span class="line">    <span class="keyword">int</span> EventSelect_return = WSAEventSelect(server_socket, EventServer, FD_ACCEPT | FD_WRITE | FD_READ);</span><br><span class="line">    <span class="keyword">if</span>(EventSelect_return == SOCKET_ERROR)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ERROR! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">        WSACloseEvent(EventServer);</span><br><span class="line">        closesocket(server_socket);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    es_set.socket_all[es_set.count] = server_socket;</span><br><span class="line">    es_set.event_all[es_set.count] = EventServer;</span><br><span class="line">    es_set.count++;</span><br><span class="line">    <span class="comment">//添加到容器中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//操作系统监控事件与该函数是异步的，这个函数只是隔一段时间向系统获取事件的情况</span></span><br><span class="line">        DWORD Wait_return = WSAWaitForMultipleEvents(es_set.count, es_set.event_all, FALSE, <span class="number">200</span>, FALSE);</span><br><span class="line">        <span class="comment">//函数错误</span></span><br><span class="line">        <span class="keyword">if</span>(Wait_return == WSA_WAIT_FAILED)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;WAIT ERROR! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//超时</span></span><br><span class="line">        <span class="keyword">if</span>(Wait_return == WSA_WAIT_TIMEOUT)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        DWORD event_index = Wait_return - WSA_WAIT_EVENT_0;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到下标对应事件</span></span><br><span class="line">        WSANETWORKEVENTS NetworkEvents;</span><br><span class="line">        <span class="keyword">int</span> n_t_return = WSAEnumNetworkEvents(es_set.socket_all[event_index], es_set.event_all[event_index], &amp;NetworkEvents);</span><br><span class="line">        <span class="keyword">if</span>(n_t_return == SOCKET_ERROR)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;GETINDEX ERROR! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(NetworkEvents.lNetworkEvents &amp; FD_ACCEPT)&#123;</span><br><span class="line">            <span class="keyword">if</span>(NetworkEvents.iErrorCode[FD_ACCEPT_BIT] == <span class="number">0</span>)&#123; <span class="comment">//等于0时为无错误码情况，正常处理</span></span><br><span class="line">                SOCKET ClientSocket = accept(es_set.socket_all[event_index], <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span>(ClientSocket == INVALID_SOCKET)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//给客户端SOCKET绑定事件</span></span><br><span class="line">                WSAEVENT ClientEvent = WSACreateEvent();</span><br><span class="line">                <span class="keyword">if</span>(ClientEvent == WSA_INVALID_EVENT)&#123;</span><br><span class="line">                    closesocket(ClientSocket);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//投递给系统监视</span></span><br><span class="line">                <span class="keyword">if</span>( WSAEventSelect(ClientSocket, ClientEvent, FD_READ | FD_CLOSE | FD_WRITE) == SOCKET_ERROR)&#123;</span><br><span class="line">                    closesocket(ClientSocket);</span><br><span class="line">                    WSACloseEvent(ClientEvent);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将链接的客户端SOCKET装入数组集合进行后续监视</span></span><br><span class="line">                es_set.socket_all[es_set.count] = ClientSocket;</span><br><span class="line">                es_set.event_all[es_set.count] = ClientEvent;</span><br><span class="line">                es_set.count++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Client Connect Success\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根据客户端信号进行分类处理</span></span><br><span class="line">        <span class="keyword">if</span>(NetworkEvents.lNetworkEvents &amp; FD_WRITE)&#123;</span><br><span class="line">            <span class="keyword">if</span>(NetworkEvents.iErrorCode[FD_WRITE_BIT] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(send(es_set.socket_all[event_index], <span class="string">&quot;CONNECT SUCCESS&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;CONNECT SUCCESS&quot;</span>), <span class="number">0</span>) == SOCKET_ERROR)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;SEND ERROR! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;CLIENT SOCKET ERROR! 错误代码: %d\n&quot;</span>,NetworkEvents.iErrorCode[FD_WRITE_BIT]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(NetworkEvents.lNetworkEvents &amp; FD_READ)&#123;</span><br><span class="line">            <span class="keyword">if</span>(NetworkEvents.iErrorCode[FD_READ_BIT] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">char</span> rec_msg[<span class="number">1500</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">if</span>(recv(es_set.socket_all[event_index], rec_msg, <span class="number">1499</span>, <span class="number">0</span>) == SOCKET_ERROR)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;RECV ERROR! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, rec_msg);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;CLIENT SOCKET ERROR! 错误代码: %d\n&quot;</span>,NetworkEvents.iErrorCode[FD_READ_BIT]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(NetworkEvents.lNetworkEvents &amp; FD_CLOSE)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Client ShutDown\n&quot;</span>);</span><br><span class="line">            <span class="comment">//清理下线客户端SOCKET与事件</span></span><br><span class="line">            closesocket(es_set.socket_all[event_index]);</span><br><span class="line">            es_set.socket_all[event_index] = es_set.socket_all[es_set.count<span class="number">-1</span>];</span><br><span class="line">            <span class="comment">//将已关闭SOCKET的位置用最后一个有效SOCKET替补，并将有效个数减一，避免移动后面所有SOCKET的情况，下同</span></span><br><span class="line">            WSACloseEvent(es_set.event_all[event_index]);</span><br><span class="line">            es_set.event_all[event_index] = es_set.event_all[es_set.count<span class="number">-1</span>];</span><br><span class="line">            es_set.count--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; es_set.count; ++n)&#123;</span><br><span class="line">		closesocket(es_set.socket_all[n]);</span><br><span class="line">		WSACloseEvent(es_set.event_all[n]);</span><br><span class="line">	&#125;</span><br><span class="line">    WSACleanup();</span><br><span class="line">	<span class="comment">//清理SOCKET、事件与网络库</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>事件分类处理逻辑</strong></p>
<p>根据事件的响应的不同进行分类处理，下面展示的代码为<code>if</code>处理，现在讨论<code>switch</code>以及<code>if-else if</code>处理的问题，else-if本质上与switch相似，当有多个事件有信号时，else-if只能处理一个满足条件，即使后面的条件依然为真，switch则更严重</p>
<p><strong>else-if示例与解释</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(NetworkEvents.lNetworkEvents &amp; FD_WRITE)&#123;</span><br><span class="line">            <span class="keyword">if</span>(NetworkEvents.iErrorCode[FD_WRITE_BIT] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(send(es_set.socket_all[event_index], <span class="string">&quot;CONNECT SUCCESS&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;CONNECT SUCCESS&quot;</span>), <span class="number">0</span>) == SOCKET_ERROR)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;SEND ERROR! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;CLIENT SOCKET ERROR! 错误代码: %d\n&quot;</span>,NetworkEvents.iErrorCode[FD_WRITE_BIT]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(NetworkEvents.lNetworkEvents &amp; FD_READ)&#123;</span><br><span class="line">    <span class="keyword">if</span>(NetworkEvents.iErrorCode[FD_READ_BIT] == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> rec_msg[<span class="number">1500</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(recv(es_set.socket_all[event_index], rec_msg, <span class="number">1499</span>, <span class="number">0</span>) == SOCKET_ERROR)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;RECV ERROR! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, rec_msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CLIENT SOCKET ERROR! 错误代码: %d\n&quot;</span>,NetworkEvents.iErrorCode[FD_READ_BIT]);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(NetworkEvents.lNetworkEvents &amp; FD_CLOSE)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Client ShutDown\n&quot;</span>);</span><br><span class="line">    <span class="comment">//清理下线客户端SOCKET与事件</span></span><br><span class="line">    closesocket(es_set.socket_all[event_index]);</span><br><span class="line">    es_set.socket_all[event_index] = es_set.socket_all[es_set.count<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">//将已关闭SOCKET的位置用最后一个有效SOCKET替补，并将有效个数减一，避免移动后面所有SOCKET的情况，下同</span></span><br><span class="line">    WSACloseEvent(es_set.event_all[event_index]);</span><br><span class="line">    es_set.event_all[event_index] = es_set.event_all[es_set.count<span class="number">-1</span>];</span><br><span class="line">    es_set.count--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当客户端链接并发送消息时，在<code>WSAEventSelect</code>函数内发生两个信号<code>READ</code>、<code>WRITE</code>，由<code>FD_XX</code>定义得，一个为01，一个为10，两个位和为11，即为3，NetworkEvents.lNetworkEvents值为3，else-if为多选一匹配，在后面匹配时先匹配<code>FD_WRITE</code>，然后就不执行后面判断了。有小问题，可以采用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (NetworkEvents.lNetworkEvents)&#123;</span><br><span class="line">        <span class="keyword">case</span> FD_ACCEPT:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> FD_WRITE:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> FD_READ:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> FD_CLOSE:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>switch</code>，首先有客户端链接时，NetworkEvents.lNetworkEvents值为8，与FD_ACCEPT匹配，正常处理，当当有多个信号时，如<code>READ</code>、<code>WRITE</code>，NetworkEvents.lNetworkEvents值为3，不与任何信号匹配，出现错误。所以不建议使用switch方法分类处理信号。</p>
<h3 id="有序优化之变态点击"><a href="#有序优化之变态点击" class="headerlink" title="有序优化之变态点击"></a>有序优化之变态点击</h3><p>解决<code>WSAWaitForMultipleEvents</code>按照我们放入es_set.event_all事件集合的事件顺序去依次遍历，而不是根据事件发生的顺序去遍历，查看有无事件被触发，而不管集合内事件发生的先后顺序，该函数一次只能处理一个事件信号，并返回下标最小事件下标，当其中一个信号一直发生时，后续事件将永远无法被处理的问题。</p>
<p>这里只解决只有一个事件被处理的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">DWORD Wait_return = WSAWaitForMultipleEvents(es_set.count, es_set.event_all, FALSE, <span class="number">0</span>, FALSE);</span><br><span class="line">        <span class="comment">//函数错误</span></span><br><span class="line">        <span class="keyword">if</span>(Wait_return == WSA_WAIT_FAILED)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;WAIT ERROR! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//超时</span></span><br><span class="line">        <span class="keyword">if</span>(Wait_return == WSA_WAIT_TIMEOUT)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">DWORD event_index = Wait_return - WSA_WAIT_EVENT_0;</span><br><span class="line"><span class="comment">//因为WSAWaitForMultipleEvents函数返回的是最小的有响应的下标，从该下标往后遍历会更加高效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> nindex = event_index;nindex &lt; es_set.count;++nindex)&#123;</span><br><span class="line">        DWORD Wait_return = WSAWaitForMultipleEvents(<span class="number">1</span>, es_set.event_all[nindex], FALSE, <span class="number">0</span>, FALSE);</span><br><span class="line">        <span class="keyword">if</span>(WSA_WAIT_FAILED == Wait_return)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WSA_WAIT_TIMEOUT == Wait_return)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面代码相同</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到下标对应事件</span></span><br><span class="line">            WSANETWORKEVENTS NetworkEvents;</span><br><span class="line">            <span class="keyword">int</span> n_t_return = WSAEnumNetworkEvents(es_set.socket_all[event_index], es_set.event_all[event_index], &amp;NetworkEvents);</span><br><span class="line">            <span class="keyword">if</span>(n_t_return == SOCKET_ERROR)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;GETINDEX ERROR! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(NetworkEvents.lNetworkEvents &amp; FD_ACCEPT)&#123;</span><br><span class="line">                <span class="keyword">if</span>(NetworkEvents.iErrorCode[FD_ACCEPT_BIT] == <span class="number">0</span>)&#123; <span class="comment">//等于0时为无错误码情况，正常处理</span></span><br><span class="line">                    SOCKET ClientSocket = accept(es_set.socket_all[event_index], <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span>(ClientSocket == INVALID_SOCKET)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//给客户端SOCKET绑定事件</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    </span></span><br><span class="line"><span class="comment">                    省略</span></span><br><span class="line"><span class="comment">                    </span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以一组一组处理，使用结构体数组，和双重循环，还有一些细节的修改，由于字数原因，这里不做展示。</p>
<p>这里只介绍下 <code>memset</code>函数，用于将目标区域设置为指定字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">void</span> *dest,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">int</span> c,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">size_t</span> count</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_socket_set</span> <span class="title">es_set</span>[20];</span></span><br><span class="line"><span class="built_in">memset</span>(es_set, <span class="number">0</span>, <span class="keyword">sizeof</span>(event_socket_set)*<span class="number">20</span>);</span><br><span class="line"><span class="comment">//将所有空间赋值为0</span></span><br></pre></td></tr></table></figure>



<h2 id="异步选择模型"><a href="#异步选择模型" class="headerlink" title="异步选择模型"></a>异步选择模型</h2><p><strong>逻辑</strong></p>
<p>核心 - 消息队列，要使用消息队列先要创建窗口，操作系统为每个窗口创建一个消息队列并维护。</p>
<p>模型实现步骤：</p>
<ol>
<li>将SOCKET绑定在一个消息上并投递给系统，使用 <code>WSAAsyncSelect</code>函数</li>
<li>取消息分类处理，有操作就会有对应的消息</li>
</ol>
<p><strong>需要 <code>windows.h</code>头文件</strong> ，<strong>该模型只能用于windows</strong></p>
<p><strong>窗口的创建</strong></p>
<ol>
<li>创建窗口结构体 <code>WNDCLASSEX</code></li>
<li>注册窗口结构体 <code>RegisterClassEx</code></li>
<li>创建窗口 <code>CreateWindowEx</code></li>
<li>显示窗口 <code>ShowWindow</code></li>
<li>消息循环 <code>GetMessage、TranslateMessage、DispatchMessage</code></li>
<li>回调函数 <code>CALLBACK</code></li>
</ol>
<p><strong>WinMain应用程序入口点</strong></p>
<p>每个Windows程序都包含一个名为<strong>WinMain</strong>或<strong>wWinMain</strong>的入口点函数，相当于控制台程序的<strong>Main</strong>函数</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR lpCmdLine, INT nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>WINAPI</strong>是调用约定。一个<em>调用约定</em>定义了一个函数从主叫方接收参数。</p>
<p><strong>函数参数</strong></p>
<p><strong>参数一：</strong> <strong>HINSTANCE</strong>为实例句柄(ID)，就是该程序的ID或名字</p>
<p><strong>参数二：</strong>已不再使用，仅作兼容，之前用来跟踪应用程序的前一个实例，即程序的父亲的程序实例</p>
<p><strong>参数三：</strong> <strong>PWSTR</strong>为命令行参数，用于传递数据</p>
<p><strong>参数四：</strong> 指示是否将主应用程序窗口最小化，最大化或正常显示</p>
<p><strong>WNDCLASSEX结构体</strong></p>
<p>用于装窗口属性，这里带了后缀Ex为扩展版本</p>
<p><strong>结构体声明</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagWNDCLASSEXA</span> &#123;</span></span><br><span class="line">  UINT      cbSize;</span><br><span class="line">  UINT      style;</span><br><span class="line">  WNDPROC   lpfnWndProc;</span><br><span class="line">  <span class="keyword">int</span>       cbClsExtra;</span><br><span class="line">  <span class="keyword">int</span>       cbWndExtra;</span><br><span class="line">  HINSTANCE hInstance;</span><br><span class="line">  HICON     hIcon;</span><br><span class="line">  HCURSOR   hCursor;</span><br><span class="line">  HBRUSH    hbrBackground;</span><br><span class="line">  LPCSTR    lpszMenuName;</span><br><span class="line">  LPCSTR    lpszClassName;</span><br><span class="line">  HICON     hIconSm;</span><br><span class="line">&#125; WNDCLASSEXA, *PWNDCLASSEXA, *NPWNDCLASSEXA, *LPWNDCLASSEXA;</span><br></pre></td></tr></table></figure>



<p><strong>窗口结构体设置</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">WNDCLASSEX SW; <span class="comment">//创建窗口结构体</span></span><br><span class="line">SW.cbClsExtra = <span class="number">0</span>; <span class="comment">//根据窗口类结构分配的额外字节数。系统将字节初始化为零。一般用不到，填0</span></span><br><span class="line">SW.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX); <span class="comment">//窗口结构体大小</span></span><br><span class="line">SW.cbWndExtra = <span class="number">0</span>; <span class="comment">//窗口实例后要分配的额外字节数。系统将字节初始化为零.一般不用，填0。</span></span><br><span class="line">SW.hbrBackground = <span class="literal">NULL</span>; <span class="comment">//窗口颜色，默认为白</span></span><br><span class="line">SW.hCursor = <span class="literal">NULL</span>; <span class="comment">//设置光标形态</span></span><br><span class="line">SW.hIcon = <span class="literal">NULL</span>; <span class="comment">//左上角图标</span></span><br><span class="line">SW.hIconSm = <span class="literal">NULL</span>; <span class="comment">//最小化图标</span></span><br><span class="line">SW.hInstance = hInstance; <span class="comment">//实例句柄，填参数一 </span></span><br><span class="line">SW.lpfnWndProc = xxxx; <span class="comment">//填回调函数名字 </span></span><br><span class="line">SW.lpszClassName = <span class="string">&quot;SynSelect&quot;</span>; <span class="comment">//当前窗口类的名字，随便起一个</span></span><br><span class="line">SW.lpszMenuName =  <span class="literal">NULL</span>; <span class="comment">//菜单</span></span><br><span class="line">SW.style = CS_HREDRAW | CS_VREDRAW; <span class="comment">//窗口风格</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">CS_HREDRAW 水平刷新  CS_VREDRAW 垂直刷新</span></span><br><span class="line"><span class="comment">窗口改变时，需要重新绘制，不然窗口就无法正常显示</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p><strong>RegisterClassEx函数</strong></p>
<p>窗口结构体带Ex这里就要带</p>
<p>用于注册结构体</p>
<p><strong>参数：</strong>窗口结构体地址</p>
<p><strong>CreateWindowEx函数</strong></p>
<p>用于创建窗口</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HWND <span class="title">CreateWindowExW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD     dwExStyle,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCWSTR   lpClassName,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCWSTR   lpWindowName,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD     dwStyle,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>       X,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>       Y,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>       nWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>       nHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">  HWND      hWndParent,</span></span></span><br><span class="line"><span class="function"><span class="params">  HMENU     hMenu,</span></span></span><br><span class="line"><span class="function"><span class="params">  HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPVOID    lpParam</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<p><strong>参数一：</strong> 窗口风格，这里用 <code>WS_EX_OVERLAPPEDWINDOW</code> 正常风格</p>
<p><strong>参数二：</strong> 窗口类名</p>
<p><strong>参数三：</strong> 窗口名字，自定</p>
<p><strong>参数四：</strong> 为窗口表面样式，这里用 <code>WS_OVERLAPPEDWINDOW</code>，多个样式使用位或</p>
<p><strong>参数五与六：</strong>为窗口起始坐标</p>
<p><strong>参数七与八：</strong> 为窗口宽与高</p>
<p><strong>参数九：</strong>副(子)窗口，我们这里没有，填<code>NULL</code></p>
<p><strong>参数十：</strong> 为菜单句柄，这里没有，填<code>NULL</code></p>
<p><strong>参数十一：</strong> 窗口句柄，填 <code>hInstance</code></p>
<p><strong>参数十二：</strong> 给回调函数传数据的参数，这里不需要，填<code>NULL</code></p>
<p><strong>返回值</strong></p>
<p>返回值是新窗口的句柄</p>
<p><strong>创建窗口</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CreateWindow(WS_EX_OVERLAPPEDWINDOW, <span class="string">&quot;SynSelect&quot;</span>, <span class="string">&quot;SynSelect_Test&quot;</span>, WS_OVERLAPPEDWINDOW, <span class="number">200</span>, <span class="number">600</span>, <span class="number">400</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>



<p><strong>ShowWindow函数</strong></p>
<p><strong>参数一：</strong> 要显示的窗口ID</p>
<p><strong>参数二：</strong> 显示方式，填<code>1</code>为正常显示，填 <code>0</code>为最小化显示，可以填主函数参数四，它默认为<code>1</code></p>
<p><strong>GetMessage函数</strong></p>
<p>用于从消息队列中取消息</p>
<p><strong>参数一：</strong> 消息结构体地址</p>
<p><strong>参数二：</strong> 窗口句柄或<code>NULL</code>，填句柄，则只从指定窗口(ID)获取消息，一个应用程序可能会有多个窗口，填 <code>NULL</code>为从整个程序窗口获取消息</p>
<p><strong>参数三与四：</strong> 为消息范围，消息本质为宏是整数，都填0，为接收所有消息</p>
<p><strong>TranslateMessage函数</strong></p>
<p>翻译消息，对消息分类</p>
<p><strong>参数为窗口结构体地址</strong></p>
<p><strong>DispatchMessage函数</strong></p>
<p>分类处理，调用回调函数</p>
<p><strong>参数为窗口结构体地址</strong></p>
<p><strong>回调函数</strong></p>
<p>由系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinBack</span><span class="params">(HWND hwnd, UINT msgID, WPARAM wparam, LPARAM lparap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>LRESULT</strong>为返回类型，本质为long型</p>
<p><strong>CALLBACK</strong>为调用约定</p>
<p><strong>参数一：</strong> 为窗口句柄</p>
<p><strong>参数二：</strong> 为消息ID</p>
<p><strong>参数三：</strong> 装SOCKET</p>
<p><strong>参数四：</strong> 装SOCKET具体事件与错误信息</p>
<h3 id="窗口实现"><a href="#窗口实现" class="headerlink" title="窗口实现"></a>窗口实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinBack</span><span class="params">(HWND hwnd, UINT msgID, WPARAM wparam, LPARAM lparap)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR lpCmdLine, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WNDCLASSEX WS; <span class="comment">//创建窗口结构体</span></span><br><span class="line">    WS.cbClsExtra = <span class="number">0</span>; <span class="comment">//根据窗口类结构分配的额外字节数。系统将字节初始化为零。一般用不到，填0</span></span><br><span class="line">    WS.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX); <span class="comment">//窗口结构体大小</span></span><br><span class="line">    WS.cbWndExtra = <span class="number">0</span>; <span class="comment">//窗口实例后要分配的额外字节数。系统将字节初始化为零.一般不用，填0。</span></span><br><span class="line">    WS.hbrBackground = <span class="literal">NULL</span>; <span class="comment">//窗口颜色，默认为白</span></span><br><span class="line">    WS.hCursor = <span class="literal">NULL</span>; <span class="comment">//设置光标形态</span></span><br><span class="line">    WS.hIcon = <span class="literal">NULL</span>; <span class="comment">//左上角图标</span></span><br><span class="line">    WS.hIconSm = <span class="literal">NULL</span>; <span class="comment">//最小化图标</span></span><br><span class="line">    WS.hInstance = hInstance; <span class="comment">//实例句柄，填参数一 </span></span><br><span class="line">    WS.lpfnWndProc = WinBack; <span class="comment">//填回调函数名字 </span></span><br><span class="line">    WS.lpszClassName = <span class="string">&quot;SynSelect&quot;</span>; <span class="comment">//当前窗口类的名字，随便起一个</span></span><br><span class="line">    WS.lpszMenuName =  <span class="literal">NULL</span>; <span class="comment">//菜单</span></span><br><span class="line">    WS.style = CS_HREDRAW | CS_VREDRAW; <span class="comment">//窗口风格</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    CS_HREDRAW 水平刷新  CS_VREDRAW 垂直刷新</span></span><br><span class="line"><span class="comment">    窗口改变时，需要重新绘制，不然窗口就无法正常显示</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//注册窗口</span></span><br><span class="line">   RegisterClassEx(&amp;WS);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建窗口</span></span><br><span class="line">   HWND hwnd = CreateWindowEx(WS_EX_OVERLAPPEDWINDOW, <span class="string">&quot;SynSelect&quot;</span>, <span class="string">&quot;SynSelect_Test&quot;</span>, WS_OVERLAPPEDWINDOW, <span class="number">200</span>, <span class="number">200</span>, <span class="number">600</span>, <span class="number">400</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示窗口</span></span><br><span class="line">    ShowWindow(hwnd, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重绘（刷新）窗口</span></span><br><span class="line">    UpdateWindow(hwnd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息循环</span></span><br><span class="line">    MSG msg; <span class="comment">//创建消息结构体</span></span><br><span class="line">    <span class="keyword">while</span>(GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))&#123;</span><br><span class="line">        TranslateMessage(&amp;msg);</span><br><span class="line">        DispatchMessage(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinBack</span><span class="params">(HWND hwnd, UINT msgID, WPARAM wparam, LPARAM lparap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(msgID)&#123;</span><br><span class="line">        <span class="keyword">case</span> WM_CREATE: <span class="comment">//窗口 初始化产生，只产生一次，可以放用于初始化的代码</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WM_DESTROY: <span class="comment">//这里WM_XX就是消息</span></span><br><span class="line">            PostQuitMessage(<span class="number">0</span>); <span class="comment">//传递退出消息，没有的话窗口关闭不了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hwnd, msgID, wparam, lparap); <span class="comment">//对没有处理的消息默认处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>开始监听及以前代码与基本C\S模型相同</p>
<p>核心函数 <code>WSAAsyncSelect</code>，作用是给SOCEKT绑定消息，并投递给系统</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WSAAsyncSelect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  SOCKET s,</span></span></span><br><span class="line"><span class="function"><span class="params">  HWND   hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  u_int  wMsg,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">long</span>   lEvent</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<p><strong>参数介绍</strong></p>
<p><strong>参数一：</strong> SOCKET</p>
<p><strong>参数二：</strong> 窗口句柄</p>
<p><strong>参数三：</strong> 网络事件发生时要接收的消息，消息本身就是一个数，消息对应的数是唯一的</p>
<p>为防止与系统已定义的消息冲突，使用宏 <code>WM_USER</code>，这个宏以下的数为系统消息所占用，以上的我们可以自己使用</p>
<p>自定义消息，可以使用 <code>#define</code> 创建宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UM_ASYNSELECT WM_USER+1</span></span><br><span class="line"><span class="comment">//自定义消息一般以U开头</span></span><br></pre></td></tr></table></figure>

<p><strong>参数四：</strong> 给SOCKET绑定操作，与事件选择模型一样</p>
<p>如果SOCKET填的是服务器SOCKET，将其与消息绑定，有客户端链接时，消息就会被触发，然后我们捕获与处理</p>
<p><strong>返回值</strong></p>
<p>出错返回<code>SOCKET_ERROR</code>，成功返回<code>0</code></p>
<p><strong>MessageBox函数</strong></p>
<p>显示一个模式对话框</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MessageBox</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HWND    hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpText,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpCaption,</span></span></span><br><span class="line"><span class="function"><span class="params">  UINT    uType</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<p><strong>参数介绍</strong></p>
<p><strong>参数一：</strong> 要创建的消息框的所有者窗口的句柄。填句柄，则为该窗口的子窗口。如果此参数为<strong>NULL</strong>，则消息框为独立窗口</p>
<p><strong>参数二：</strong> 要显示的消息</p>
<p><strong>参数三：</strong> 窗口标题</p>
<p><strong>参数四：</strong> 窗口风格</p>
<p><strong>TextOut函数</strong></p>
<p>在窗口上输出文本</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">TextOutA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HDC    hdc,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>    x,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>    y,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR lpString,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>    c</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<p><strong>参数介绍</strong></p>
<p><strong>参数一：</strong> 窗口显示区（去掉窗口名字显示的那个头部框的部分）的句柄</p>
<p>使用 <code>GetDC函数</code>得到该句柄，参数为窗口句柄，<code>HDC</code>类型</p>
<p><strong>参数二与三：</strong> 显示字符串的位置</p>
<p><strong>参数四：</strong> 要输出的字符串</p>
<p><strong>参数五：</strong> 字符串长度</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UM_ASYNSELECT WM_USER+1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCKET_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinBack</span><span class="params">(HWND hwnd, UINT msgID, WPARAM wparam, LPARAM lparap)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AllSockets</span> &#123;</span></span><br><span class="line">    SOCKET sockets[SOCKET_SIZE];</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;; <span class="comment">//存放所有SOCKET的结构体</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AllSockets</span> <span class="title">all_sockets</span>;</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR lpCmdLine, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WNDCLASSEX WS; <span class="comment">//创建窗口结构体</span></span><br><span class="line">    WS.cbClsExtra = <span class="number">0</span>; <span class="comment">//根据窗口类结构分配的额外字节数。系统将字节初始化为零。一般用不到，填0</span></span><br><span class="line">    WS.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX); <span class="comment">//窗口结构体大小</span></span><br><span class="line">    WS.cbWndExtra = <span class="number">0</span>; <span class="comment">//窗口实例后要分配的额外字节数。系统将字节初始化为零.一般不用，填0。</span></span><br><span class="line">    WS.hbrBackground = <span class="literal">NULL</span>; <span class="comment">//窗口颜色，默认为白</span></span><br><span class="line">    WS.hCursor = <span class="literal">NULL</span>; <span class="comment">//设置光标形态</span></span><br><span class="line">    WS.hIcon = <span class="literal">NULL</span>; <span class="comment">//左上角图标</span></span><br><span class="line">    WS.hIconSm = <span class="literal">NULL</span>; <span class="comment">//最小化图标</span></span><br><span class="line">    WS.hInstance = hInstance; <span class="comment">//实例句柄，填参数一 </span></span><br><span class="line">    WS.lpfnWndProc = WinBack; <span class="comment">//填回调函数名字 </span></span><br><span class="line">    WS.lpszClassName = <span class="string">&quot;SynSelect&quot;</span>; <span class="comment">//当前窗口类的名字，随便起一个</span></span><br><span class="line">    WS.lpszMenuName =  <span class="literal">NULL</span>; <span class="comment">//菜单</span></span><br><span class="line">    WS.style = CS_HREDRAW | CS_VREDRAW; <span class="comment">//窗口风格</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    CS_HREDRAW 水平刷新  CS_VREDRAW 垂直刷新</span></span><br><span class="line"><span class="comment">    窗口改变时，需要重新绘制，不然窗口就无法正常显示</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//注册窗口</span></span><br><span class="line">   RegisterClassEx(&amp;WS);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建窗口</span></span><br><span class="line">   HWND hwnd = CreateWindowEx(WS_EX_OVERLAPPEDWINDOW, <span class="string">&quot;SynSelect&quot;</span>, <span class="string">&quot;SynSelect_Test&quot;</span>, WS_OVERLAPPEDWINDOW, <span class="number">200</span>, <span class="number">200</span>, <span class="number">600</span>, <span class="number">400</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == hwnd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示窗口</span></span><br><span class="line">    ShowWindow(hwnd, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重绘（刷新）窗口</span></span><br><span class="line">    UpdateWindow(hwnd);</span><br><span class="line"></span><br><span class="line">    WORD WSversion = MAKEWORD(<span class="number">2</span>,<span class="number">2</span>);  <span class="comment">//版本号</span></span><br><span class="line">    WSADATA ServerSocket;</span><br><span class="line">    <span class="keyword">int</span> return_WASA = WSAStartup(WSversion,&amp;ServerSocket);</span><br><span class="line">    <span class="keyword">if</span>(return_WASA!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;初始化网络库失败!&quot;</span>);</span><br><span class="line">        WSACleanup();  <span class="comment">//清理网络库</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//启动网络库</span></span><br><span class="line"></span><br><span class="line">    SOCKET Socket_Server = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="comment">//创建服务端SOCKET Socket_Server</span></span><br><span class="line">    <span class="keyword">if</span>(Socket_Server == INVALID_SOCKET)&#123;</span><br><span class="line">        <span class="comment">//INVALID_SOCKET为socket函数返回失败值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建SOCKET失败!&quot;</span>);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建SOCKDET</span></span><br><span class="line"></span><br><span class="line">    all_sockets.count = <span class="number">0</span>;</span><br><span class="line">    all_sockets.sockets[all_sockets.count] = Socket_Server;</span><br><span class="line">    all_sockets.count++;</span><br><span class="line">    <span class="comment">//将服务端SOCKET装入数组</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">bind_info</span>;</span></span><br><span class="line">    bind_info.sin_family = AF_INET;</span><br><span class="line">    bind_info.sin_port = htons(<span class="number">2333</span>);</span><br><span class="line">    bind_info.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="comment">//配置协议端口与IP地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bind_return = bind(Socket_Server,(<span class="keyword">const</span> struct sockaddr *)&amp;bind_info,<span class="keyword">sizeof</span>(bind_info));</span><br><span class="line">    <span class="keyword">if</span>(bind_return == SOCKET_ERROR)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;绑定地址与端口失败!&quot;</span>);</span><br><span class="line">        closesocket(Socket_Server);  <span class="comment">//关闭SOCKET</span></span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> listen_return = listen(Socket_Server,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//开始监听客户端连接</span></span><br><span class="line">    <span class="keyword">if</span>(listen_return == SOCKET_ERROR)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;监听失败!&quot;</span>);</span><br><span class="line">        closesocket(Socket_Server);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Listening...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给SOCEKT绑定消息，并投递给系统</span></span><br><span class="line">    <span class="keyword">if</span>(WSAAsyncSelect(Socket_Server, hwnd, UM_ASYNSELECT, FD_ACCEPT) == SOCKET_ERROR)&#123;</span><br><span class="line">        closesocket(Socket_Server);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息循环</span></span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="keyword">while</span>(GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))&#123;</span><br><span class="line">        TranslateMessage(&amp;msg);</span><br><span class="line">        DispatchMessage(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">0</span>; n&lt;all_sockets.count; ++n)&#123;</span><br><span class="line">        closesocket(all_sockets.sockets[n]);</span><br><span class="line">        WSACleanup();</span><br><span class="line">    &#125; <span class="comment">//关闭全部SOCKET与清理网络库</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinBack</span><span class="params">(HWND hwnd, UINT msgID, WPARAM wparam, LPARAM lparam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SOCKET socket;</span><br><span class="line">    HDC hdc = GetDC(hwnd); <span class="comment">//获取窗口显示区句柄</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(msgID)&#123;</span><br><span class="line">        <span class="keyword">case</span> WM_CREATE: <span class="comment">//窗口 初始化产生，只产生一次，可以放用于初始化的代码</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WM_DESTROY: <span class="comment">//这里WM_XX就是消息</span></span><br><span class="line">            PostQuitMessage(<span class="number">0</span>); <span class="comment">//传递退出消息，没有的话窗口关闭不了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> UM_ASYNSELECT:</span><br><span class="line">            socket = (SOCKET)wparam; <span class="comment">//获取SOCKET</span></span><br><span class="line">            <span class="keyword">if</span>(HIWORD(lparam) != <span class="number">0</span>)&#123; <span class="comment">//判断消息是否出错</span></span><br><span class="line">                <span class="keyword">if</span>(WSAECONNABORTED == HIWORD(lparam))&#123; <span class="comment">//客户端关闭</span></span><br><span class="line">                    WSAAsyncSelect(socket, hwnd, UM_ASYNSELECT, <span class="number">0</span>); <span class="comment">//取消SOCKET上的消息</span></span><br><span class="line">                    closesocket(socket);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> n =<span class="number">0</span>; n&lt;all_sockets.count; ++n)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(socket == all_sockets.sockets[n])&#123;</span><br><span class="line">                            all_sockets.sockets[n] = all_sockets.sockets[all_sockets.count<span class="number">-1</span>];</span><br><span class="line">                            all_sockets.count--;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    TextOut(hdc, <span class="number">0</span>, x, <span class="string">&quot;Client Close&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;Client Close&quot;</span>));</span><br><span class="line">                    x+=<span class="number">15</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//具体消息</span></span><br><span class="line">            <span class="keyword">switch</span>(LOWORD(lparam))&#123;</span><br><span class="line">                <span class="keyword">case</span> FD_ACCEPT:</span><br><span class="line">                    TextOut(hdc, <span class="number">0</span>, x, <span class="string">&quot;Client Connect&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;Client Connect&quot;</span>)); <span class="comment">//输出字符</span></span><br><span class="line">                    x+=<span class="number">15</span>;</span><br><span class="line">                    SOCKET Socket_Client = accept(socket, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span>(Socket_Client == INVALID_SOCKET)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    MessageBox(<span class="literal">NULL</span>, <span class="string">&quot;Client Connect!&quot;</span>, <span class="string">&quot;Prompt&quot;</span>, MB_OK); <span class="comment">//弹出窗口</span></span><br><span class="line">                    <span class="comment">//将客户端SOCKET绑定消息并投递给消息队列</span></span><br><span class="line">                    <span class="keyword">if</span>(WSAAsyncSelect(Socket_Client, hwnd, UM_ASYNSELECT, FD_READ | FD_WRITE | FD_CLOSE) == SOCKET_ERROR)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;ACCEPT ERROR! 错误代码: %d\n&quot;</span>,WSAGetLastError());</span><br><span class="line">                        closesocket(Socket_Client);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    all_sockets.sockets[all_sockets.count] = Socket_Client;</span><br><span class="line">                    all_sockets.count++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> FD_READ:</span><br><span class="line">                &#123;</span><br><span class="line">					<span class="keyword">char</span> recv_msg[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">					<span class="keyword">if</span> (SOCKET_ERROR == recv(socket, recv_msg, <span class="number">1023</span>, <span class="number">0</span>))</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					TextOut(hdc, <span class="number">30</span>, x, recv_msg, <span class="built_in">strlen</span>(recv_msg));</span><br><span class="line">					x += <span class="number">15</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> FD_WRITE:</span><br><span class="line">                    TextOut(hdc, <span class="number">0</span>, x, <span class="string">&quot;write&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;write&quot;</span>));</span><br><span class="line">                    x+=<span class="number">15</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> FD_CLOSE:</span><br><span class="line">                    WSAAsyncSelect(socket, hwnd, UM_ASYNSELECT, <span class="number">0</span>); <span class="comment">//取消SOCKET上的消息</span></span><br><span class="line">                    closesocket(socket);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> n =<span class="number">0</span>; n&lt;all_sockets.count; ++n)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(socket == all_sockets.sockets[n])&#123;</span><br><span class="line">                            all_sockets.sockets[n] = all_sockets.sockets[all_sockets.count<span class="number">-1</span>];</span><br><span class="line">                            all_sockets.count--;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    TextOut(hdc, <span class="number">0</span>, x, <span class="string">&quot;Client Close&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;Client Close&quot;</span>));</span><br><span class="line">                    x+=<span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hwnd, msgID, wparam, lparam); <span class="comment">//对没有处理的消息默认处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>优化：</strong> 每个窗口维护一定的SOCKET，当SOCKET过多时，延迟会增大，我们可以创建多个线程，每个线程管理一个窗口，每个窗口投递一定数量的客户端。当然线程不是万能的，也有最大处理效率。</p>
<p><strong>问题：</strong> 在一次处理过程中，客户端产生多次send，服务端会产生多次接收的消息，第一次接收消息会收完所有信息。</p>
<h2 id="重叠IO模型"><a href="#重叠IO模型" class="headerlink" title="重叠IO模型"></a>重叠IO模型</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意义：</strong> 重叠IO是windows提供的一种异步读写文件的机制，SOCKET本质是文件操作，如<code>recv</code>，是阻塞的，等协议缓冲区的数据全部复制进buffer(缓冲区)里，函数才结束并返回复制的个数，写也一样，同一时间只能执行一个，也就是执行阻塞。</p>
<p><strong>作用：</strong> 系统多开线程，同时处理(异步)</p>
<p><strong>实现：</strong>将<code>accept、recv、send</code>优化为异步处理过程，用<code>AcceptEx、WSARecv、WSASend</code>函数代替它们，是对基本C/S模型的直接优化</p>
<p><strong>本质：</strong> 结构体(重叠结构) <code>WSAOVERLAPPED</code>，定义一个该结构体的变量与SOCKET绑定</p>
<p><strong>使用：</strong> 重叠IO模型把重叠结构与SOCKET绑定在一起并投递给系统，然后系统以重叠机制处理反馈</p>
<p>重叠IO反馈的两种方式：<strong>事件通知</strong> - 调用AcceptEx等函数并投递被完成的操作，事件信号被置为有信号，调用WSAWaitForMultipleEvents获取事件信号、<strong>完成历程</strong> - 回调函数。可以单独或者配合使用。</p>
<p><strong>性能：</strong> 来源网络，普通电脑链接2w个SOCKET，同时请求send，CPU占用上涨40%(重叠IO模型)；完成端口CPU占用上涨2%左右</p>
<h3 id="事件通知"><a href="#事件通知" class="headerlink" title="事件通知"></a>事件通知</h3><p><strong>实现逻辑</strong></p>
<ol>
<li>创建重叠IO模型使用的SOCKET 使用 <code>WSAScoekt</code>创建</li>
<li>投递-AcceptEx<ul>
<li>立即完成，系统空闲且正好有链接<ul>
<li>对客户端套接字投递 <code>WSARecv</code><ol>
<li>立即完成-处理信息，对客户端套接字投递 <code>WSARecv</code></li>
<li>延迟完成-去循环等信号</li>
</ol>
</li>
<li>根据需求对客户端套接字投递 <code>WSASend</code><ol>
<li>立即完成-处理信息，根据需求投递 <code>WSASend</code></li>
<li>延迟完成-去循环等信号</li>
</ol>
</li>
<li>对服务器套接字继续投递 <code>AcceptEx</code>,重复上述</li>
</ul>
</li>
<li>延迟完成，系统开线程等待链接(异步)，去循环里等信号，有就分类处理</li>
</ul>
</li>
<li>循环等信号<ul>
<li>等信号- <code>WSAWaitForMultipleEvents</code>函数</li>
<li>有信号<ul>
<li>获取重叠结构上的信息 <code>WSAGetOverlappedResult</code>函数</li>
<li>客户端退出，删除服务端的信息</li>
<li>接收链接 - 投递  <code>AcceptEx</code></li>
<li>接收信息 - 处理消息，对客户端套接字投递 <code>WSARecv</code></li>
<li>发送消息，根据需求投递 <code>WSASend</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>WSASocket函数</strong></p>
<p>创建用于异步操作的SOCKET</p>
<p><code>WSA</code>前缀的函数是windows专用的函数</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SOCKET WSAAPI <span class="title">WSASocket</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>                 af,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>                 type,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>                 protocol,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPWSAPROTOCOL_INFOW lpProtocolInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">  GROUP               g,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD               dwFlags</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数介绍</strong></p>
<p>与原 <code>socket</code>函数参数不同的参数：</p>
<p><strong>参数四：</strong> 定义了要创建的套接字的特性，不使用填 <code>NULL</code>，这里用不到</p>
<p><strong>参数五：</strong> 保留参数，暂时无用，填<code>0</code></p>
<p><strong>参数六：</strong> 指定套接字属性，填 <strong><code>WSA_FLAG_OVERLAPPED</code></strong> - 创建一个支持重叠IO操作的套接字</p>
<p><strong>返回值</strong></p>
<p>成功，返回可用套接字，失败返回 <code>INVALID_SOCKET</code></p>
<p><strong>AcceptEx函数</strong></p>
<p>投递服务器SOCKET，让操作系统开一根线程监视，随时接收客户端链接</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">AcceptEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  SOCKET       sListenSocket,</span></span></span><br><span class="line"><span class="function"><span class="params">  SOCKET       sAcceptSocket,</span></span></span><br><span class="line"><span class="function"><span class="params">  PVOID        lpOutputBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD        dwReceiveDataLength,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD        dwLocalAddressLength,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD        dwRemoteAddressLength,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD      lpdwBytesReceived,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPOVERLAPPED lpOverlapped</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数介绍</strong></p>
<p><strong>参数一：</strong> 服务器SOCKET</p>
<p><strong>参数二：</strong> 自定义SOCKET，有客户端链接时，IP与端口号绑定在此</p>
<p><strong>参数三：</strong> 指向缓冲区的指针，客户端发来的第一组数据由该参数(字符数组)接收，第二次以后由<code>recv</code>接收，不能设置为<code>NULL</code></p>
<p><strong>参数四：</strong> 参数三数组大小，设置<code>0</code>，取消参数三的功能，一般用不到三，所以我们填0</p>
<p><strong>参数五：</strong> 为本地地址信息保留的字节数，该值必须比使用的传输协议的最大地址长度至少多16个字节，不能为0，<strong>存储客户端IP与端口号</strong></p>
<p><strong>参数六：</strong> 为远程地址信息保留的字节数，该值必须比使用的传输协议的最大地址长度至少多16个字节。不能为零。与参数五填一样就行。</p>
<p><strong>参数七：</strong> 填NULL</p>
<p><strong>参数八：</strong> 服务器SOCKET的重叠结构</p>
<p><strong>返回值</strong></p>
<p>立即完成返回 <code>TRUE</code>，出错返回 <code>FALSE</code></p>
<p>使用 <code>WSAGetLastError</code>函数得到错误代码，若为 <code>ERROR_IO_PENDING</code>表示延时处理需要单独处理，其他错误码为错误</p>
<p><strong>WSARecv函数</strong></p>
<p>投递异步接收信息</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WSAAPI <span class="title">WSARecv</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  SOCKET                             s,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPWSABUF                           lpBuffers,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                              dwBufferCount,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD                            lpNumberOfBytesRecvd,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD                            lpFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPWSAOVERLAPPED                    lpOverlapped,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数</strong></p>
<p><strong>参数一：</strong> 客户端SOCKET</p>
<p><strong>参数二：</strong> 接收后信息储存的缓冲区 <code>WSABUF</code>型结构体</p>
<p><strong>WSABUF</strong>：成员一为缓冲区的长度，以字节为单位，成员二为指向缓冲区的指针</p>
<p>使用示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WSABUF wsabuf;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">wsabuf.buf = str;</span><br><span class="line">wsabuf.len = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数三：</strong> 是<code>WSABUF</code>的个数</p>
<p><strong>参数四：</strong> 接收成功装成功接收到的字符数。参数六为NULL时，不能为NULL</p>
<p><strong>参数五：</strong> 指向用于修改<strong>WSARecv</strong>函数调用行为的标志的指针 ，填 <strong><code>MSG_PUSH_IMMEDIATE</code></strong>-该标志允许使用流套接字的应用程序告诉传输提供者不要延迟部分填充的未决接收请求的完成。处理小信息好。</p>
<p><strong>参数六：</strong> 对应SOCKET的重叠结构</p>
<p><strong>参数七：</strong> 回调函数，完成例程时使用，这里填 <code>NULL</code></p>
<p><strong>返回值</strong></p>
<p>立即发生返回0， 错误返回<code>SOCKET_ERROR</code>，使用<code>WSAGetLastError</code>函数得到错误代码，若为 <code>ERROR_IO_PENDING</code>表示延时处理需要单独处理</p>
<p><strong>WSAGetOverlappedResult函数</strong></p>
<p>获取对应SOCKET上的具体情况：客户端链接、消息等</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WSAAPI <span class="title">WSAGetOverlappedResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  SOCKET          s,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPWSAOVERLAPPED lpOverlapped,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD         lpcbTransfer,</span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL            fWait,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD         lpdwFlags</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数介绍</strong></p>
<p><strong>参数一：</strong> 有信号的SOCKET</p>
<p><strong>参数二：</strong> 对应的重叠结构</p>
<p><strong>参数三：</strong> 发送或者接收到的实际字节数，不能为<code>NULL</code>,参数为0表示客户端下线</p>
<p><strong>参数四：</strong> 选择事件通知模型填<code>TRUE</code></p>
<p><strong>参数五：</strong> 装<code>WSARecv</code>的参数五，不能是<code>NULL</code>，如果重叠操作是通过<code>WSARecv</code>或 <code>WSARecvFrom</code>启动的 ，则此参数将包含<code>lpFlags</code>参数的结果值。此参数不能为<code>NULL</code>指针。</p>
<p><strong>返回值</strong></p>
<p>成功返回 <code>TRUE</code>， 错误返回 <code>FALSE</code>，获得错误码，如果为<code>10054</code>则为客户端强制退出</p>
<p><strong>WSASend函数</strong></p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WSAAPI <span class="title">WSASend</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  SOCKET                             s,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPWSABUF                           lpBuffers,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                              dwBufferCount,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD                            lpNumberOfBytesSent,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                              dwFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPWSAOVERLAPPED                    lpOverlapped,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数介绍</strong></p>
<p><strong>参数一：</strong> 客户端SOCKET</p>
<p><strong>参数二：</strong> 接收信息储存的buffer</p>
<p><strong>参数三：</strong> WSABUF的个数</p>
<p><strong>参数四：</strong> 接收成功，装发送成功的字节数</p>
<p><strong>参数五：</strong> 函数调用行为标志</p>
<p><strong>参数六：</strong> 重叠结构</p>
<p><strong>参数七：</strong> 回调函数</p>
<p><strong>返回值</strong></p>
<p>立即发生：<code>0    失败</code> <code>SOCKET_ERROR</code> 获取错误代码若为 <code>ERROR_IO_PENDING</code>表示延时处理需要单独处理</p>
<h3 id="事件通知代码实现"><a href="#事件通知代码实现" class="headerlink" title="事件通知代码实现"></a>事件通知代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mswsock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE_SOCKET 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE_BUF 1024</span></span><br><span class="line"></span><br><span class="line">SOCKET allsocket[MAXSIZE_SOCKET]; <span class="comment">//创建SOCKET数组</span></span><br><span class="line">OVERLAPPED alloverlapp[MAXSIZE_SOCKET]; <span class="comment">//创建重叠结构体数组</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">char</span> str[MAXSIZE_BUF] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 接收缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PostAccept</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PostRecv</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PostSend</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span></span>; <span class="comment">//清理函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WORD WSversion = MAKEWORD(<span class="number">2</span>,<span class="number">2</span>);  <span class="comment">//版本号</span></span><br><span class="line">    WSADATA ServerSocket;</span><br><span class="line">    <span class="keyword">int</span> return_WASA = WSAStartup(WSversion,&amp;ServerSocket);</span><br><span class="line">    <span class="keyword">if</span>(return_WASA!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;初始化网络库失败!&quot;</span>);</span><br><span class="line">        WSACleanup();  <span class="comment">//清理网络库</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//启动网络库</span></span><br><span class="line"></span><br><span class="line">    SOCKET Socket_Server = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, <span class="literal">NULL</span>, <span class="number">0</span>, WSA_FLAG_OVERLAPPED);</span><br><span class="line">    <span class="comment">//创建服务端SOCKET Socket_Server</span></span><br><span class="line">    <span class="keyword">if</span>(Socket_Server == INVALID_SOCKET)&#123;</span><br><span class="line">        <span class="comment">//INVALID_SOCKET为socket函数返回失败值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建SOCKET失败!&quot;</span>);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建SOCKDET</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">bind_info</span>;</span></span><br><span class="line">    bind_info.sin_family = AF_INET;</span><br><span class="line">    bind_info.sin_port = htons(<span class="number">2333</span>);</span><br><span class="line">    bind_info.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="comment">//配置协议端口与IP地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bind_return = bind(Socket_Server,(<span class="keyword">const</span> struct sockaddr *)&amp;bind_info,<span class="keyword">sizeof</span>(bind_info));</span><br><span class="line">    <span class="keyword">if</span>(bind_return == SOCKET_ERROR)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;绑定地址与端口失败!&quot;</span>);</span><br><span class="line">        closesocket(Socket_Server);  <span class="comment">//关闭SOCKET</span></span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> listen_return = listen(Socket_Server,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//开始监听客户端连接</span></span><br><span class="line">    <span class="keyword">if</span>(listen_return == SOCKET_ERROR)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;监听失败!&quot;</span>);</span><br><span class="line">        closesocket(Socket_Server);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Listening...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    allsocket[count] = Socket_Server;</span><br><span class="line">    alloverlapp[count].hEvent = WSACreateEvent(); <span class="comment">//给重叠结构的事件成员赋值一个合法的事件</span></span><br><span class="line">    count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(PostAccept() != <span class="number">0</span>)&#123;</span><br><span class="line">        Clear();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="comment">//函数的调用逻辑比较复杂，我们封装成一个函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123; <span class="comment">//循环等待事件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">0</span>;n &lt; count;++n)&#123;</span><br><span class="line">            <span class="keyword">int</span> wait_return = WSAWaitForMultipleEvents(<span class="number">1</span>, &amp;alloverlapp[n].hEvent, FALSE, <span class="number">0</span>, FALSE);</span><br><span class="line">            <span class="keyword">if</span>(wait_return == WSA_WAIT_TIMEOUT || wait_return == WSA_WAIT_FAILED)&#123; <span class="comment">//超时或错误</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            DWORD dwstate;</span><br><span class="line">            DWORD dwflag;</span><br><span class="line">            BOOL get_return = WSAGetOverlappedResult(allsocket[n], &amp;alloverlapp[n], &amp;dwstate, TRUE, &amp;dwflag);</span><br><span class="line"></span><br><span class="line">            WSAResetEvent(alloverlapp[n].hEvent); <span class="comment">//信号制空</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(get_return == FALSE)&#123;</span><br><span class="line">                <span class="keyword">if</span>(GetLastError() == <span class="number">10054</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Client Close\n&quot;</span>);</span><br><span class="line">                    closesocket(allsocket[n]);</span><br><span class="line">                    WSACloseEvent(alloverlapp[n].hEvent);</span><br><span class="line">                    allsocket[n] = allsocket[count<span class="number">-1</span>];</span><br><span class="line">                    alloverlapp[n] = alloverlapp[count<span class="number">-1</span>];</span><br><span class="line">                    n--; <span class="comment">//循环控制变量减一</span></span><br><span class="line">                    count--; <span class="comment">//个数减一</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span>)&#123; <span class="comment">//接受链接完成</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Client Connect\n&quot;</span>);</span><br><span class="line">                PostRecv(count);</span><br><span class="line">                count++;</span><br><span class="line">                PostAccept();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dwstate == <span class="number">0</span>)&#123; <span class="comment">//客户端下线</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Client Close\n&quot;</span>);</span><br><span class="line">                closesocket(allsocket[n]);</span><br><span class="line">                WSACloseEvent(alloverlapp[n].hEvent);</span><br><span class="line">                allsocket[n] = allsocket[count<span class="number">-1</span>];</span><br><span class="line">                alloverlapp[n] = alloverlapp[count<span class="number">-1</span>];</span><br><span class="line">                n--; <span class="comment">//循环控制变量减一</span></span><br><span class="line">                count--; <span class="comment">//个数减一</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dwstate != <span class="number">0</span>)&#123; <span class="comment">//发送或者接收成功</span></span><br><span class="line">                <span class="keyword">if</span>(str[<span class="number">0</span>] != <span class="number">0</span>)&#123; <span class="comment">//接收成功</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Client: %s\n&quot;</span>, str);</span><br><span class="line">                    <span class="built_in">memset</span>(str, <span class="number">0</span>, MAXSIZE_BUF); <span class="comment">//打印信息与清空缓冲区</span></span><br><span class="line">                    PostRecv(n); <span class="comment">//递归，继续投递recv</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//发送成功</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Send Success\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Clear();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PostAccept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    allsocket[count] =  WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, <span class="literal">NULL</span>, <span class="number">0</span>, WSA_FLAG_OVERLAPPED); <span class="comment">//使用socket函数也可以，但该函数更好</span></span><br><span class="line">    alloverlapp[count].hEvent = WSACreateEvent();</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    BOOL Acp_return = AcceptEx(allsocket[<span class="number">0</span>], allsocket[count], str, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr_in)+<span class="number">16</span>, <span class="keyword">sizeof</span>(struct sockaddr_in)+<span class="number">16</span>, <span class="literal">NULL</span>, &amp;alloverlapp[<span class="number">0</span>]); <span class="comment">//基本地址长度为sizeof(struct sockaddr_in)</span></span><br><span class="line">    <span class="keyword">if</span>(Acp_return == FALSE)&#123; <span class="comment">//错误处理</span></span><br><span class="line">    <span class="keyword">int</span> error = WSAGetLastError();</span><br><span class="line">        <span class="keyword">if</span>(error == ERROR_IO_PENDING)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//延时处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> error; <span class="comment">//出错</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//立即完成</span></span><br><span class="line">        PostRecv(count); <span class="comment">//投递recv</span></span><br><span class="line">        count++;</span><br><span class="line">        PostAccept(); <span class="comment">//立即完成就递归</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PostRecv</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WSABUF wsabuf;</span><br><span class="line">    wsabuf.buf = str;</span><br><span class="line">    wsabuf.len = MAXSIZE_BUF;</span><br><span class="line">    DWORD buffcount;</span><br><span class="line">    DWORD dwflag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> recv_return = WSARecv(allsocket[index], &amp;wsabuf, <span class="number">1</span>, &amp;buffcount, &amp;dwflag, &amp;alloverlapp[index], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(recv_return == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//立即完成</span></span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Client: %s&quot;</span>, str);</span><br><span class="line">            <span class="built_in">memset</span>(str, <span class="number">0</span>, MAXSIZE_BUF); <span class="comment">//打印信息与清空缓冲区</span></span><br><span class="line">        &#125;</span><br><span class="line">        PostRecv(index); <span class="comment">//递归，继续投递recv</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> error = WSAGetLastError();</span><br><span class="line">        <span class="keyword">if</span>(error == WSA_IO_PENDING)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//延迟处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PostSend</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WSABUF wsabuf;</span><br><span class="line">    wsabuf.buf = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    wsabuf.len = MAXSIZE_BUF;</span><br><span class="line">    DWORD dwSendCount;</span><br><span class="line">	DWORD dwFlag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> nRes = WSASend(allsocket[index], &amp;wsabuf, <span class="number">1</span>, &amp;dwSendCount, dwFlag, &amp;alloverlapp[index], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == nRes)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//立即完成的</span></span><br><span class="line">		<span class="comment">//打印信息</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;send成功\n&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> a = WSAGetLastError();</span><br><span class="line">		<span class="keyword">if</span> (ERROR_IO_PENDING == a)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//延迟处理</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> a;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">0</span>;n &lt; count; ++n)&#123;</span><br><span class="line">        closesocket(allsocket[n]);</span><br><span class="line">        WSACloseEvent(alloverlapp[n].hEvent);</span><br><span class="line">    &#125;</span><br><span class="line">    WSACleanup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="完成例程"><a href="#完成例程" class="headerlink" title="完成例程"></a>完成例程</h3><p><strong>本质：</strong> 为我们的SOCKET，重叠结构绑定一个函数，当异步操作完成时，系统异步自动调用这个函数 ， <code>send</code>绑一个 <code>recv</code>绑一个，完成就调用各自的函数，然后我们在函数内做相应的操作。在分类方式上，完成例程性能更好，系统自动调用处理</p>
<p><strong>逻辑：</strong> 与事件通知基本相同，延时处理变成了回调函数处理</p>
<p><strong>不同：</strong> 在函数 <code>WSARecv WSASend</code> 最后一个参数上填上回调函数</p>
<p><strong>回调函数介绍</strong></p>
<p><strong>LPWSAOVERLAPPED_COMPLETION_ROUTINE回调函数</strong></p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> CALLBACK <span class="title">LpwsaoverlappedCompletionRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwError,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD cbTransferred,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPWSAOVERLAPPED lpOverlapped,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwFlags</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数介绍</strong></p>
<p><strong>参数一：</strong> 错误码</p>
<p><strong>参数二：</strong> 发送或接收到的字节数</p>
<p><strong>参数三：</strong> 重叠结构</p>
<p><strong>参数四：</strong> 函数的执行方式</p>
<p>与 <code>WSAGetOverlappedResult</code>函数对比，参数基本相同</p>
<p><strong>处理流程</strong></p>
<p><code>dwError=10054</code>-强行退出，删除客户端</p>
<p><code>cbTransferred=0</code>，正常退出；不等于0，接收成功</p>
<p>都不是，得到或发送完数据，继续投递接收请求</p>
<p><strong>完成例程事件分类处理</strong></p>
<p>由于所有的客户端的响应都在回调函数中做了，在 <code>WSAWaitForMultipleEvents</code>等待循环中就不用再处理了，只用处理服务器<code>SOCKET</code>对应事件就行了，<code>WSAWaitForMultipleEvents</code>函数参数五设置 <code>WSA_INFINITE</code>一直等待，参数六填 <code>TRUE</code>，将事件等待与完成例程机制结合在一起，实现等待事件函数与完成例程函数异步执行，完成例程函数执行完并给等待事件函数信号，事件函数返回  <code>WSA_WAIT_IO_COMPLETION</code>，被等待函数接收。此时返回值判断需要修改。</p>
<h3 id="完成例程代码实现"><a href="#完成例程代码实现" class="headerlink" title="完成例程代码实现"></a><strong>完成例程代码实现</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mswsock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE_SOCKET 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE_BUF 1024</span></span><br><span class="line"></span><br><span class="line">SOCKET allsocket[MAXSIZE_SOCKET]; <span class="comment">//创建SOCKET数组</span></span><br><span class="line">OVERLAPPED alloverlapp[MAXSIZE_SOCKET]; <span class="comment">//创建重叠结构体数组</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">char</span> str[MAXSIZE_BUF] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 接收缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PostAccept</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PostRecv</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PostSend</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> CALLBACK <span class="title">Recv_call</span><span class="params">(DWORD dwError, DWORD cbTransferred, LPWSAOVERLAPPED lpOverlapped, DWORD dwFlags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> CALLBACK <span class="title">Send_call</span><span class="params">(DWORD dwError, DWORD cbTransferred, LPWSAOVERLAPPED lpOverlapped, DWORD dwFlags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span></span>; <span class="comment">//清理函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WORD WSversion = MAKEWORD(<span class="number">2</span>,<span class="number">2</span>);  <span class="comment">//版本号</span></span><br><span class="line">    WSADATA ServerSocket;</span><br><span class="line">    <span class="keyword">int</span> return_WASA = WSAStartup(WSversion,&amp;ServerSocket);</span><br><span class="line">    <span class="keyword">if</span>(return_WASA!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;初始化网络库失败!&quot;</span>);</span><br><span class="line">        WSACleanup();  <span class="comment">//清理网络库</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//启动网络库</span></span><br><span class="line"></span><br><span class="line">    SOCKET Socket_Server = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, <span class="literal">NULL</span>, <span class="number">0</span>, WSA_FLAG_OVERLAPPED);</span><br><span class="line">    <span class="comment">//创建服务端SOCKET Socket_Server</span></span><br><span class="line">    <span class="keyword">if</span>(Socket_Server == INVALID_SOCKET)&#123;</span><br><span class="line">        <span class="comment">//INVALID_SOCKET为socket函数返回失败值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建SOCKET失败!&quot;</span>);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建SOCKDET</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">bind_info</span>;</span></span><br><span class="line">    bind_info.sin_family = AF_INET;</span><br><span class="line">    bind_info.sin_port = htons(<span class="number">2333</span>);</span><br><span class="line">    bind_info.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="comment">//配置协议端口与IP地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bind_return = bind(Socket_Server,(<span class="keyword">const</span> struct sockaddr *)&amp;bind_info,<span class="keyword">sizeof</span>(bind_info));</span><br><span class="line">    <span class="keyword">if</span>(bind_return == SOCKET_ERROR)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;绑定地址与端口失败!&quot;</span>);</span><br><span class="line">        closesocket(Socket_Server);  <span class="comment">//关闭SOCKET</span></span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> listen_return = listen(Socket_Server,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//开始监听客户端连接</span></span><br><span class="line">    <span class="keyword">if</span>(listen_return == SOCKET_ERROR)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;监听失败!&quot;</span>);</span><br><span class="line">        closesocket(Socket_Server);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Listening...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    allsocket[count] = Socket_Server;</span><br><span class="line">    alloverlapp[count].hEvent = WSACreateEvent(); <span class="comment">//给重叠结构的事件成员赋值一个合法的事件</span></span><br><span class="line">    count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(PostAccept() != <span class="number">0</span>)&#123;</span><br><span class="line">        Clear();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="comment">//函数的调用逻辑比较复杂，我们封装成一个函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123; <span class="comment">//循环等待事件</span></span><br><span class="line">        <span class="keyword">int</span> wait_return = WSAWaitForMultipleEvents(<span class="number">1</span>, &amp;(alloverlapp[<span class="number">0</span>].hEvent), FALSE, WSA_INFINITE, TRUE);</span><br><span class="line">        <span class="keyword">if</span>(wait_return == WSA_WAIT_IO_COMPLETION || wait_return == WSA_WAIT_FAILED)&#123; <span class="comment">//完成例程执行完或错误</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WSAResetEvent(alloverlapp[<span class="number">0</span>].hEvent); <span class="comment">//信号制空</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Client Connect\n&quot;</span>);</span><br><span class="line">        PostRecv(count);</span><br><span class="line">        count++;</span><br><span class="line">        PostAccept();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Clear();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PostAccept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    allsocket[count] =  WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, <span class="literal">NULL</span>, <span class="number">0</span>, WSA_FLAG_OVERLAPPED); <span class="comment">//使用socket函数也可以，但该函数更好</span></span><br><span class="line">    alloverlapp[count].hEvent = WSACreateEvent();</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    BOOL Acp_return = AcceptEx(allsocket[<span class="number">0</span>], allsocket[count], str, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr_in)+<span class="number">16</span>, <span class="keyword">sizeof</span>(struct sockaddr_in)+<span class="number">16</span>, <span class="literal">NULL</span>, &amp;alloverlapp[<span class="number">0</span>]); <span class="comment">//基本地址长度为sizeof(struct sockaddr_in)</span></span><br><span class="line">    <span class="keyword">if</span>(Acp_return == FALSE)&#123; <span class="comment">//错误处理</span></span><br><span class="line">    <span class="keyword">int</span> error = WSAGetLastError();</span><br><span class="line">        <span class="keyword">if</span>(error == ERROR_IO_PENDING)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//延时处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> error; <span class="comment">//出错</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//立即完成</span></span><br><span class="line">        PostRecv(count); <span class="comment">//投递recv</span></span><br><span class="line">        count++;</span><br><span class="line">        PostAccept(); <span class="comment">//立即完成就递归</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PostRecv</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WSABUF wsabuf;</span><br><span class="line">    wsabuf.buf = str;</span><br><span class="line">    wsabuf.len = MAXSIZE_BUF;</span><br><span class="line">    DWORD buffcount;</span><br><span class="line">    DWORD dwflag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> recv_return = WSARecv(allsocket[index], &amp;wsabuf, <span class="number">1</span>, &amp;buffcount, &amp;dwflag, &amp;alloverlapp[index], Recv_call);</span><br><span class="line">    <span class="keyword">if</span>(recv_return == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//立即完成</span></span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Client: %s&quot;</span>, str);</span><br><span class="line">            <span class="built_in">memset</span>(str, <span class="number">0</span>, MAXSIZE_BUF); <span class="comment">//打印信息与清空缓冲区</span></span><br><span class="line">        &#125;</span><br><span class="line">        PostRecv(index); <span class="comment">//递归，继续投递recv</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> error = WSAGetLastError();</span><br><span class="line">        <span class="keyword">if</span>(error == WSA_IO_PENDING)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//延迟处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PostSend</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WSABUF wsabuf;</span><br><span class="line">    wsabuf.buf = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    wsabuf.len = MAXSIZE_BUF;</span><br><span class="line">    DWORD dwSendCount;</span><br><span class="line">	DWORD dwFlag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> nRes = WSASend(allsocket[index], &amp;wsabuf, <span class="number">1</span>, &amp;dwSendCount, dwFlag, &amp;alloverlapp[index], Send_call);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == nRes)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//立即完成的</span></span><br><span class="line">		<span class="comment">//打印信息</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;send成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> a = WSAGetLastError();</span><br><span class="line">		<span class="keyword">if</span> (ERROR_IO_PENDING == a)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//延迟处理</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> a;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">0</span>;n &lt; count; ++n)&#123;</span><br><span class="line">        closesocket(allsocket[n]);</span><br><span class="line">        WSACloseEvent(alloverlapp[n].hEvent);</span><br><span class="line">    &#125;</span><br><span class="line">    WSACleanup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> CALLBACK <span class="title">Recv_call</span><span class="params">(DWORD dwError, DWORD cbTransferred, LPWSAOVERLAPPED lpOverlapped, DWORD dwFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = lpOverlapped - &amp;alloverlapp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(dwError == <span class="number">10054</span> || cbTransferred == <span class="number">0</span>)&#123; <span class="comment">//客户端退出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Client Close\n&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> index = lpOverlapped - &amp;alloverlapp[<span class="number">0</span>];</span><br><span class="line">        closesocket(allsocket[index]);</span><br><span class="line">        WSACloseEvent(alloverlapp[index].hEvent);</span><br><span class="line">        allsocket[index] = allsocket[count<span class="number">-1</span>];</span><br><span class="line">        alloverlapp[index] = alloverlapp[count<span class="number">-1</span>];</span><br><span class="line">        count--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Client: %s\n&quot;</span>, str);</span><br><span class="line">            <span class="built_in">memset</span>(str, MAXSIZE_BUF, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PostRecv(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> CALLBACK <span class="title">Send_call</span><span class="params">(DWORD dwError, DWORD cbTransferred, LPWSAOVERLAPPED lpOverlapped, DWORD dwFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Send Success\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>简单总结</strong></p>
<p>事件通知是我们自己分配任务，顺序不能保证，循环次数多，下标越大客户端延迟越大</p>
<p>完成例程是客户端根据具体事件自动调用代码，自动分类处理问题与异步选择相似</p>
<h2 id="完成端口模型"><a href="#完成端口模型" class="headerlink" title="完成端口模型"></a>完成端口模型</h2><p>完成端口也是windows的一种机制，在重叠IO模型上的优化</p>
<p><strong>重叠IO问题</strong></p>
<ul>
<li>事件通知<ol>
<li>无序</li>
<li>循环询问 - 延迟高</li>
<li>采用多线程 - 数量多、管理难</li>
</ol>
</li>
<li>完成例程 - 线程数量多，每个客户端都有一个线程去调用对调函数，线程过多-切换线程消耗大量CPU资源</li>
<li>完成端口<ol>
<li>模仿消息队列，创造一个通知队列，由系统创建，保证有序，不做无用功</li>
<li>创建最佳数量的线程，充分利用CPU资源</li>
</ol>
</li>
</ul>
<p><strong>线程数量分析</strong></p>
<p>一般创建与CPU核数相同的线程数就可以了</p>
<p><strong>完成端口代码逻辑</strong></p>
<p><strong>原理：</strong> 将重叠套接字与一个完成端口变量(一种类型的变量)绑定在一起，使用<code>AcceptEx、WSARecv、WSASend</code>投递请求。当系统异步完成请求，就会把通知存进一个队列，我们就叫它通知队列，该队列由操作系统创建与维护。完成端口可以理解为这个队列的头，通过 <code>GetQueuedCompletionStatus</code>从队列头往外拿，一个个处理。</p>
<p><strong>代码</strong></p>
<ul>
<li>创建完成端口 <code>CreateIoCompletionPort</code> </li>
<li>将完成端口与SOCKET绑定 <code>CreateIoCompletionPort</code></li>
<li>创建指定数量的线程<ul>
<li>与CPU核数一样 - <code>CreateThread</code></li>
<li>线程内部<ul>
<li><code>GetQueuedCompletionStatus</code></li>
<li>分类处理</li>
</ul>
</li>
</ul>
</li>
<li>使用<code>AcceptEx、WSARecv、WSASend</code>投递请求，主线程阻塞</li>
</ul>
<p><strong>创建完成端口 - CreateIoCompletionPort函数</strong></p>
<p>在监听前创建并与服务器套接字绑定</p>
<p><strong>功能</strong></p>
<p>参数不同，功能不同</p>
<ul>
<li>创建完成端口</li>
<li>将完成端口与套接字绑定</li>
</ul>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateIoCompletionPort</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     HANDLE    FileHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ HANDLE    ExistingCompletionPort,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     ULONG_PTR CompletionKey,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     DWORD     NumberOfConcurrentThreads</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数介绍</strong></p>
<p><strong>参数一</strong> </p>
<ol>
<li>填 <code>INVALID_HANDLE_VALUE</code>宏，此时参数二必须为 <code>NULL</code>，参数三忽略-填<code>0</code></li>
<li>服务器<code>SOCKET</code></li>
</ol>
<p><strong>参数二</strong> </p>
<ol>
<li><code>NULL</code></li>
<li>完成端口变量</li>
</ol>
<p><strong>参数三</strong> </p>
<ol>
<li>0</li>
<li>再次传递服务器套接字与系统接收到的数据关联在一起，也可以传下标</li>
</ol>
<p><strong>参数四</strong> </p>
<ol>
<li>最多同时运行线程数量，等于CPU核数就行，填0自动获取CPU核数，也可以使用 <code>GetSysteminfo</code>获取</li>
<li>忽略，填0</li>
</ol>
<p><strong>返回值</strong></p>
<p><strong>成功</strong></p>
<ol>
<li>参二为NULL，返回一个新的完成端口</li>
<li>参二不为NULL，返回自己(端口变量)</li>
<li>参一为SOCKET，返回与SOCKET绑定的端口变量，自己</li>
</ol>
<p><strong>失败</strong></p>
<p>0，获取错误码，关闭句柄</p>
<p><strong>创建线程 - CreateThread函数</strong></p>
<p>调用该函数只创建一根线程，所以我们需要获取CPU核数</p>
<p> <strong><code>GetSystemInfo()函数</code></strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetSystemInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPSYSTEM_INFO lpSystemInfo</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数为指向 <code>SystemInfo</code>结构体的指针</strong></p>
<p>该结构体只介绍一个成员 - <code>dwNumberOfProcessors</code></p>
<p><strong>使用</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYSTEM_INFO SystemInfo;</span><br><span class="line">GetSystemInfo(&amp;SystemInfo);</span><br><span class="line"><span class="keyword">int</span> nProcessorsCount = SystemInfo.dwNumberOfProcessors;</span><br></pre></td></tr></table></figure>



<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES   lpThreadAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">  SIZE_T                  dwStackSize,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPTHREAD_START_ROUTINE  lpStartAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">  __drv_aliasesMem LPVOID lpParameter,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                   dwCreationFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD                 lpThreadId</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数介绍</strong></p>
<p><strong>参数一：</strong> 线程句柄是否能被继承 <code>NULL</code>-不被继承 指定线程的执行权限 <code>NULL</code>-默认</p>
<p><strong>参数二：</strong> 线程栈大小，以字节为单位 填0，系统使用默认大小 1M = 1024*1024byte</p>
<p><strong>参数三：</strong> 线程函数地址 <code>ThreadPort()</code>的参数是参四传递进的数据，线程本质是执行线程函数内的代码</p>
<p><strong>参数四：</strong> 外部给线程传递数据</p>
<p><strong>参数五：</strong> <code>0</code> - 线程立即执行，填0就行；填<code>CREATE_SUSPENDED</code>线程挂起，等待状态；填 <code>STACK_SIZE_PARAM_IS_A_RESERVATION</code>指定堆栈的初始保留大小</p>
<p><strong>参数六：</strong> 线程ID，可以填<code>NULL</code>，我们可以通过返回值获取</p>
<p><strong>返回值</strong></p>
<p>成功 - 返回线程句柄，最后记得要释放</p>
<p>失败 - <code>NULL</code>，得到错误码</p>
<p><strong>ThreadProc回调函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ LPVOID lpParameter</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<p><strong>GetQueuedCompletionStatus函数</strong></p>
<p>无通知时，线程挂起，不占用CPU的时间</p>
<p>功能：尝试从指定的IO完成端口取IO完成数据包</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetQueuedCompletionStatus</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE       CompletionPort,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD      lpNumberOfBytesTransferred,</span></span></span><br><span class="line"><span class="function"><span class="params">  PULONG_PTR   lpCompletionKey,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPOVERLAPPED *lpOverlapped,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD        dwMilliseconds</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数介绍</strong></p>
<p><strong>参数一：</strong> 完成端口</p>
<p><strong>参数二：</strong> 接收或发送的字节数</p>
<p><strong>参数三：</strong> 完成端口 <code>CreateIoCompletionPort</code>函数参数三传进来的</p>
<p><strong>参数四：</strong> 重叠结构</p>
<p><strong>参数五：</strong> 等待时间 <code>INFINITE</code>一直等</p>
<p><strong>返回值</strong></p>
<p>成功<code>TRUE</code> 失败<code>FALSE</code></p>
<h3 id="完成端口代码实现"><a href="#完成端口代码实现" class="headerlink" title="完成端口代码实现"></a>完成端口代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mswsock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE_SOCKET 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE_BUF 1024</span></span><br><span class="line"></span><br><span class="line">SOCKET allsocket[MAXSIZE_SOCKET]; <span class="comment">//创建SOCKET数组</span></span><br><span class="line">OVERLAPPED alloverlapp[MAXSIZE_SOCKET]; <span class="comment">//创建重叠结构体数组</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">char</span> str[MAXSIZE_BUF] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 接收缓冲区</span></span><br><span class="line">HANDLE hport;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PostAccept</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PostRecv</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PostSend</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//清理函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WORD WSversion = MAKEWORD(<span class="number">2</span>,<span class="number">2</span>);  <span class="comment">//版本号</span></span><br><span class="line">    WSADATA ServerSocket;</span><br><span class="line">    <span class="keyword">int</span> return_WASA = WSAStartup(WSversion,&amp;ServerSocket);</span><br><span class="line">    <span class="keyword">if</span>(return_WASA!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;初始化网络库失败!&quot;</span>);</span><br><span class="line">        WSACleanup();  <span class="comment">//清理网络库</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//启动网络库</span></span><br><span class="line"></span><br><span class="line">    SOCKET Socket_Server = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, <span class="literal">NULL</span>, <span class="number">0</span>, WSA_FLAG_OVERLAPPED);</span><br><span class="line">    <span class="comment">//创建服务端SOCKET Socket_Server</span></span><br><span class="line">    <span class="keyword">if</span>(Socket_Server == INVALID_SOCKET)&#123;</span><br><span class="line">        <span class="comment">//INVALID_SOCKET为socket函数返回失败值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建SOCKET失败!&quot;</span>);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建SOCKDET</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">bind_info</span>;</span></span><br><span class="line">    bind_info.sin_family = AF_INET;</span><br><span class="line">    bind_info.sin_port = htons(<span class="number">2333</span>);</span><br><span class="line">    bind_info.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="comment">//配置协议端口与IP地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bind_return = bind(Socket_Server,(<span class="keyword">const</span> struct sockaddr *)&amp;bind_info,<span class="keyword">sizeof</span>(bind_info));</span><br><span class="line">    <span class="keyword">if</span>(bind_return == SOCKET_ERROR)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;绑定地址与端口失败!&quot;</span>);</span><br><span class="line">        closesocket(Socket_Server);  <span class="comment">//关闭SOCKET</span></span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    allsocket[count] = Socket_Server;</span><br><span class="line">    alloverlapp[count].hEvent = WSACreateEvent(); <span class="comment">//给重叠结构的事件成员赋值一个合法的事件</span></span><br><span class="line">    count++;</span><br><span class="line"></span><br><span class="line">    hport = CreateIoCompletionPort(INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//创建完成端口</span></span><br><span class="line">    <span class="keyword">if</span>(hport == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> error = GetLastError();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ERROR CODE: %d\n&quot;</span>, error);</span><br><span class="line">        closesocket(Socket_Server);</span><br><span class="line">        <span class="comment">//WSACloseEvent(alloverlapp[0].hEvent);</span></span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HANDLE s_hport = CreateIoCompletionPort((HANDLE)Socket_Server, hport, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//绑定socket</span></span><br><span class="line">    <span class="keyword">if</span>(s_hport != hport)&#123;</span><br><span class="line">        <span class="keyword">int</span> error = GetLastError();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ERROR CODE: %d\n&quot;</span>, error);</span><br><span class="line">        closesocket(Socket_Server);</span><br><span class="line">        CloseHandle(hport);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> listen_return = listen(Socket_Server,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//开始监听客户端连接</span></span><br><span class="line">    <span class="keyword">if</span>(listen_return == SOCKET_ERROR)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;监听失败!&quot;</span>);</span><br><span class="line">        closesocket(Socket_Server);</span><br><span class="line">        CloseHandle(hport);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Listening...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != PostAccept())</span><br><span class="line">	&#123;</span><br><span class="line">		Clear();</span><br><span class="line">		<span class="comment">//清理网络库</span></span><br><span class="line">		WSACleanup();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    SYSTEM_INFO SystemInfo;</span><br><span class="line">    GetSystemInfo(&amp;SystemInfo);</span><br><span class="line">    <span class="keyword">int</span> nProcessorsCount = SystemInfo.dwNumberOfProcessors; <span class="comment">//获取CPU核数</span></span><br><span class="line"></span><br><span class="line">    HANDLE *pthread = (HANDLE *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HANDLE)*nProcessorsCount); <span class="comment">//创建线程数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; nProcessorsCount; ++n)&#123;</span><br><span class="line">        pthread[n] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, hport, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(pthread[n] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> error = GetLastError();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR CODE: %d\n&quot;</span>, error);</span><br><span class="line">            closesocket(Socket_Server);</span><br><span class="line">            CloseHandle(hport);</span><br><span class="line">            WSACleanup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123; <span class="comment">//主线程阻塞，防止程序(线程)结束</span></span><br><span class="line">        Sleep(<span class="number">1000</span>); <span class="comment">//休眠1s，线程挂起</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">0</span>;n &lt; nProcessorsCount;++n)&#123;</span><br><span class="line">        CloseHandle(pthread[n]);</span><br><span class="line">    &#125; <span class="comment">//清理线程</span></span><br><span class="line">    <span class="built_in">free</span>(pthread); <span class="comment">//释放线程数组</span></span><br><span class="line">    CloseHandle(hport);</span><br><span class="line">    Clear();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span> <span class="comment">//线程函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE port = (HANDLE)lpParameter;</span><br><span class="line">    DWORD NumberOfBytes;</span><br><span class="line">    LONG_PTR index;</span><br><span class="line">    LPOVERLAPPED lpOverlapped;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        BOOL bflag = GetQueuedCompletionStatus(port, &amp;NumberOfBytes, &amp;index, &amp;lpOverlapped, INFINITE);</span><br><span class="line">        <span class="keyword">if</span>(bflag == FALSE)&#123;</span><br><span class="line">            <span class="keyword">if</span>(GetLastError() == <span class="number">64</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Client Close\n&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR CODE: %d\n&quot;</span>, GetLastError());</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理accept</span></span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Client Connect\n&quot;</span>);</span><br><span class="line">            <span class="comment">//绑定到完成端口</span></span><br><span class="line">            HANDLE hport1 = CreateIoCompletionPort((HANDLE)allsocket[count], hport, count, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(hport1 != hport)&#123;</span><br><span class="line">                <span class="keyword">int</span> error = GetLastError();</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ERROR CODE: %d\n&quot;</span>, error);</span><br><span class="line">                closesocket(allsocket[count]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//新客户端投递recv</span></span><br><span class="line">            PostRecv(count);</span><br><span class="line">            count++;</span><br><span class="line">            PostAccept();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(NumberOfBytes == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//客户端正常下线</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Client Close\n&quot;</span>);</span><br><span class="line">                closesocket(allsocket[index]);</span><br><span class="line">                WSACloseEvent(alloverlapp[index].hEvent);</span><br><span class="line">                allsocket[index] = <span class="number">0</span>;</span><br><span class="line">                alloverlapp[index].hEvent = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(str[<span class="number">0</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//recv</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">                    <span class="built_in">memset</span>(str, <span class="number">0</span>, MAXSIZE_BUF);</span><br><span class="line">                    PostRecv(index);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//send</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PostAccept</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    allsocket[count] =  WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, <span class="literal">NULL</span>, <span class="number">0</span>, WSA_FLAG_OVERLAPPED); <span class="comment">//使用socket函数也可以，但该函数更好</span></span><br><span class="line">    alloverlapp[count].hEvent = WSACreateEvent();</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    BOOL Acp_return = AcceptEx(allsocket[<span class="number">0</span>], allsocket[count], str, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr_in)+<span class="number">16</span>, <span class="keyword">sizeof</span>(struct sockaddr_in)+<span class="number">16</span>, <span class="literal">NULL</span>, &amp;alloverlapp[<span class="number">0</span>]); <span class="comment">//基本地址长度为sizeof(struct sockaddr_in)</span></span><br><span class="line">    <span class="keyword">if</span>(Acp_return == FALSE)&#123; <span class="comment">//错误处理</span></span><br><span class="line">    <span class="keyword">int</span> error = WSAGetLastError();</span><br><span class="line">        <span class="keyword">if</span>(error == ERROR_IO_PENDING)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//延时处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> error; <span class="comment">//出错</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//立即完成</span></span><br><span class="line">        HANDLE hport1 = CreateIoCompletionPort((HANDLE)allsocket[count], hport, count, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(hport1 != hport)&#123;</span><br><span class="line">            <span class="keyword">int</span> error = GetLastError();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR CODE: %d\n&quot;</span>, error);</span><br><span class="line">            closesocket(allsocket[count]);</span><br><span class="line">        &#125;</span><br><span class="line">        PostRecv(count); <span class="comment">//投递recv</span></span><br><span class="line">        count++;</span><br><span class="line">        PostAccept(); <span class="comment">//立即完成就递归</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PostRecv</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WSABUF wsabuf;</span><br><span class="line">    wsabuf.buf = str;</span><br><span class="line">    wsabuf.len = MAXSIZE_BUF;</span><br><span class="line">    DWORD buffcount;</span><br><span class="line">    DWORD dwflag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> recv_return = WSARecv(allsocket[index], &amp;wsabuf, <span class="number">1</span>, &amp;buffcount, &amp;dwflag, &amp;alloverlapp[index], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(recv_return == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//立即完成</span></span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Client: %s&quot;</span>, str);</span><br><span class="line">            <span class="built_in">memset</span>(str, <span class="number">0</span>, MAXSIZE_BUF); <span class="comment">//打印信息与清空缓冲区</span></span><br><span class="line">        &#125;</span><br><span class="line">        PostRecv(index); <span class="comment">//递归，继续投递recv</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> error = WSAGetLastError();</span><br><span class="line">        <span class="keyword">if</span>(error == WSA_IO_PENDING)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//延迟处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PostSend</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WSABUF wsabuf;</span><br><span class="line">    wsabuf.buf = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    wsabuf.len = MAXSIZE_BUF;</span><br><span class="line">    DWORD dwSendCount;</span><br><span class="line">	DWORD dwFlag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> nRes = WSASend(allsocket[index], &amp;wsabuf, <span class="number">1</span>, &amp;dwSendCount, dwFlag, &amp;alloverlapp[index], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == nRes)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//立即完成的</span></span><br><span class="line">		<span class="comment">//打印信息</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;send成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> a = WSAGetLastError();</span><br><span class="line">		<span class="keyword">if</span> (ERROR_IO_PENDING == a)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//延迟处理</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> a;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">0</span>;n &lt; count; ++n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(allsocket[n] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        closesocket(allsocket[n]);</span><br><span class="line">        WSACloseEvent(alloverlapp[n].hEvent);</span><br><span class="line">    &#125;</span><br><span class="line">    WSACleanup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h1><p>本教程到此结束，你学废了吗？有问题的小伙伴们欢迎在评论区友好交流。</p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="vcomments">
                <!--Valine-->
                <script src="/js/Valine.min.js"></script>
            <!--id disqus_thread  <noscript>Please enable JavaScript to view the comments.</noscript>-->
            <script>
                new Valine({
                    el: '#vcomments',
                    appId: 'yEI6RlVJLA4pYwjBexhwdp8j-gzGzoHsz',
                    appKey: '0oz4352SSpNVsruE6U11qzhQ',
                     // 设置贴吧表情包地址
                    emojiCDN: '//valinecdn.bili33.top/', 
                    // 表情title和图片映射
                    emojiMaps: {
                        "Tieba-New2": "Tieba-New/image_emoticon.png",
                        "Tieba-New3": "Tieba-New/image_emoticon10.png",
                        "Tieba-New4": "Tieba-New/image_emoticon100.png",
                        "Tieba-New5": "Tieba-New/image_emoticon101.png",
                        "Tieba-New6": "Tieba-New/image_emoticon102.png",
                        "Tieba-New7": "Tieba-New/image_emoticon103.png",
                        "Tieba-New8": "Tieba-New/image_emoticon104.png",
                        "Tieba-New9": "Tieba-New/image_emoticon105.png",
                        "Tieba-New10": "Tieba-New/image_emoticon106.png",
                        "Tieba-New11": "Tieba-New/image_emoticon107.png",
                        "Tieba-New12": "Tieba-New/image_emoticon108.png",
                        "Tieba-New13": "Tieba-New/image_emoticon109.png",
                        "Tieba-New14": "Tieba-New/image_emoticon11.png",
                        "Tieba-New15": "Tieba-New/image_emoticon110.png",
                        "Tieba-New16": "Tieba-New/image_emoticon111.png",
                        "Tieba-New17": "Tieba-New/image_emoticon112.png",
                        "Tieba-New18": "Tieba-New/image_emoticon113.png",
                        "Tieba-New19": "Tieba-New/image_emoticon114.png",
                        "Tieba-New20": "Tieba-New/image_emoticon115.png",
                        "Tieba-New21": "Tieba-New/image_emoticon116.png",
                        "Tieba-New22": "Tieba-New/image_emoticon117.png",
                        "Tieba-New23": "Tieba-New/image_emoticon118.png",
                        "Tieba-New24": "Tieba-New/image_emoticon119.png",
                        "Tieba-New25": "Tieba-New/image_emoticon12.png",
                        "Tieba-New26": "Tieba-New/image_emoticon120.png",
                        "Tieba-New27": "Tieba-New/image_emoticon121.png",
                        "Tieba-New28": "Tieba-New/image_emoticon122.png",
                        "Tieba-New29": "Tieba-New/image_emoticon123.png",
                        "Tieba-New30": "Tieba-New/image_emoticon124.png",
                        "Tieba-New31": "Tieba-New/image_emoticon13.png",
                        "Tieba-New32": "Tieba-New/image_emoticon14.png",
                        "Tieba-New33": "Tieba-New/image_emoticon15.png",
                        "Tieba-New34": "Tieba-New/image_emoticon16.png",
                        "Tieba-New35": "Tieba-New/image_emoticon17.png",
                        "Tieba-New36": "Tieba-New/image_emoticon18.png",
                        "Tieba-New37": "Tieba-New/image_emoticon19.png",
                        "Tieba-New38": "Tieba-New/image_emoticon2.png",
                        "Tieba-New39": "Tieba-New/image_emoticon20.png",
                        "Tieba-New40": "Tieba-New/image_emoticon21.png",
                        "Tieba-New41": "Tieba-New/image_emoticon22.png",
                        "Tieba-New42": "Tieba-New/image_emoticon23.png",
                        "Tieba-New43": "Tieba-New/image_emoticon24.png",
                        "Tieba-New44": "Tieba-New/image_emoticon25.png",
                        "Tieba-New45": "Tieba-New/image_emoticon26.png",
                        "Tieba-New46": "Tieba-New/image_emoticon27.png",
                        "Tieba-New47": "Tieba-New/image_emoticon28.png",
                        "Tieba-New48": "Tieba-New/image_emoticon29.png",
                        "Tieba-New49": "Tieba-New/image_emoticon3.png",
                        "Tieba-New50": "Tieba-New/image_emoticon30.png",
                        "Tieba-New51": "Tieba-New/image_emoticon31.png",
                        "Tieba-New52": "Tieba-New/image_emoticon32.png",
                        "Tieba-New53": "Tieba-New/image_emoticon33.png",
                        "Tieba-New54": "Tieba-New/image_emoticon34.png",
                        "Tieba-New55": "Tieba-New/image_emoticon35.png",
                        "Tieba-New56": "Tieba-New/image_emoticon36.png",
                        "Tieba-New57": "Tieba-New/image_emoticon37.png",
                        "Tieba-New58": "Tieba-New/image_emoticon38.png",
                        "Tieba-New59": "Tieba-New/image_emoticon39.png",
                        "Tieba-New60": "Tieba-New/image_emoticon4.png",
                        "Tieba-New61": "Tieba-New/image_emoticon40.png",
                        "Tieba-New62": "Tieba-New/image_emoticon41.png",
                        "Tieba-New63": "Tieba-New/image_emoticon42.png",
                        "Tieba-New64": "Tieba-New/image_emoticon43.png",
                        "Tieba-New65": "Tieba-New/image_emoticon44.png",
                        "Tieba-New66": "Tieba-New/image_emoticon45.png",
                        "Tieba-New67": "Tieba-New/image_emoticon46.png",
                        "Tieba-New68": "Tieba-New/image_emoticon47.png",
                        "Tieba-New69": "Tieba-New/image_emoticon48.png",
                        "Tieba-New70": "Tieba-New/image_emoticon49.png",
                        "Tieba-New71": "Tieba-New/image_emoticon5.png",
                        "Tieba-New72": "Tieba-New/image_emoticon50.png",
                        "Tieba-New73": "Tieba-New/image_emoticon6.png",
                        "Tieba-New74": "Tieba-New/image_emoticon66.png",
                        "Tieba-New75": "Tieba-New/image_emoticon67.png",
                        "Tieba-New76": "Tieba-New/image_emoticon68.png",
                        "Tieba-New77": "Tieba-New/image_emoticon69.png",
                        "Tieba-New78": "Tieba-New/image_emoticon7.png",
                        "Tieba-New79": "Tieba-New/image_emoticon70.png",
                        "Tieba-New80": "Tieba-New/image_emoticon71.png",
                        "Tieba-New81": "Tieba-New/image_emoticon72.png",
                        "Tieba-New82": "Tieba-New/image_emoticon73.png",
                        "Tieba-New83": "Tieba-New/image_emoticon74.png",
                        "Tieba-New84": "Tieba-New/image_emoticon75.png",
                        "Tieba-New85": "Tieba-New/image_emoticon76.png",
                        "Tieba-New86": "Tieba-New/image_emoticon77.png",
                        "Tieba-New87": "Tieba-New/image_emoticon78.png",
                        "Tieba-New88": "Tieba-New/image_emoticon79.png",
                        "Tieba-New89": "Tieba-New/image_emoticon8.png",
                        "Tieba-New90": "Tieba-New/image_emoticon80.png",
                        "Tieba-New91": "Tieba-New/image_emoticon81.png",
                        "Tieba-New92": "Tieba-New/image_emoticon82.png",
                        "Tieba-New93": "Tieba-New/image_emoticon83.png",
                        "Tieba-New94": "Tieba-New/image_emoticon84.png",
                        "Tieba-New95": "Tieba-New/image_emoticon85.png",
                        "Tieba-New96": "Tieba-New/image_emoticon86.png",
                        "Tieba-New97": "Tieba-New/image_emoticon87.png",
                        "Tieba-New98": "Tieba-New/image_emoticon88.png",
                        "Tieba-New99": "Tieba-New/image_emoticon89.png",
                        "Tieba-New100": "Tieba-New/image_emoticon9.png",
                        "Tieba-New101": "Tieba-New/image_emoticon90.png",
                        "Tieba-New102": "Tieba-New/image_emoticon91.png",
                        "Tieba-New103": "Tieba-New/image_emoticon92.png",
                        "Tieba-New104": "Tieba-New/image_emoticon93.png",
                        "Tieba-New105": "Tieba-New/image_emoticon94.png",
                        "Tieba-New106": "Tieba-New/image_emoticon95.png",
                        "Tieba-New107": "Tieba-New/image_emoticon96.png",
                        "Tieba-New108": "Tieba-New/image_emoticon97.png",
                        "Tieba-New109": "Tieba-New/image_emoticon98.png",
                        "Tieba-New110": "Tieba-New/image_emoticon99.png",
                        // ... 更多表情
                    } 
                })
            </script>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/projects_url">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSOCKET"><span class="toc-number">2.</span> <span class="toc-text">什么是SOCKET</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SOCKET%E7%AE%80%E4%BB%8B%E4%B8%8E%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">SOCKET简介与简单的网络通信原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ETCP-IP%E7%9A%84C-S%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">基于TCP&#x2F;IP的C&#x2F;S通信模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">TCP&#x2F;IP协议的简单介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SOCKET%E9%80%9A%E4%BF%A1%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.2.</span> <span class="toc-text">SOCKET通信步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows%E7%BD%91%E7%BB%9C%E5%BA%93%E4%B8%8E%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">3.3.</span> <span class="toc-text">Windows网络库与头文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BD%91%E7%BB%9C%E5%BA%93-WSAStartup-%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.4.</span> <span class="toc-text">初始化网络库-WSAStartup()函数与返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VScode%E9%85%8D%E7%BD%AE"><span class="toc-number">3.5.</span> <span class="toc-text">VScode配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%A5%97%E6%8E%A5%E5%AD%97-socket-%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.6.</span> <span class="toc-text">创建套接字-socket()函数与返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E6%9C%AC%E5%9C%B0socket-bind-%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.7.</span> <span class="toc-text">绑定本地socket-bind()函数与返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E9%93%BE%E6%8E%A5-listen-%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.8.</span> <span class="toc-text">监听链接-listen()函数与返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%93%BE%E6%8E%A5-connect-%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.9.</span> <span class="toc-text">与服务端链接-connect()函数与返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%97%E9%93%BE%E6%8E%A5-accept-%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.10.</span> <span class="toc-text">接受链接-accept()函数与返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E4%BF%A1%E6%81%AF-recv-%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.11.</span> <span class="toc-text">接收信息-recv()函数与返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E4%BF%A1%E6%81%AF-send-%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.12.</span> <span class="toc-text">发送信息-send()函数与返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Server%E7%AB%AF%E5%AE%8C%E6%95%B4%E7%BC%96%E5%86%99"><span class="toc-number">3.13.</span> <span class="toc-text">Server端完整编写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Client%E7%AB%AF%E5%AE%8C%E6%95%B4%E7%BC%96%E5%86%99"><span class="toc-number">3.14.</span> <span class="toc-text">Client端完整编写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C"><span class="toc-number">3.15.</span> <span class="toc-text">运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">3.16.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-S%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">C&#x2F;S模型优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#select-%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">select()模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="toc-number">4.1.1.</span> <span class="toc-text">特点与原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93"><span class="toc-number">4.1.3.</span> <span class="toc-text">模型总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%85%B3%E9%97%AD%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.1.4.</span> <span class="toc-text">控制台关闭事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%80%89%E6%8B%A9%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">事件选择模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E4%BC%98%E5%8C%96%E4%B9%8B%E5%8F%98%E6%80%81%E7%82%B9%E5%87%BB"><span class="toc-number">4.2.2.</span> <span class="toc-text">有序优化之变态点击</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E9%80%89%E6%8B%A9%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">异步选择模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.1.</span> <span class="toc-text">窗口实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">4.3.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%8F%A0IO%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.4.</span> <span class="toc-text">重叠IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.4.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5"><span class="toc-number">4.4.2.</span> <span class="toc-text">事件通知</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.4.3.</span> <span class="toc-text">事件通知代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E4%BE%8B%E7%A8%8B"><span class="toc-number">4.4.4.</span> <span class="toc-text">完成例程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E4%BE%8B%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.4.5.</span> <span class="toc-text">完成例程代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E7%AB%AF%E5%8F%A3%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.5.</span> <span class="toc-text">完成端口模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E7%AB%AF%E5%8F%A3%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.5.1.</span> <span class="toc-text">完成端口代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%8C%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">完结</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2021/01/23/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2021/01/23/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&text=Socket网络编程"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2021/01/23/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&title=Socket网络编程"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2021/01/23/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&is_video=false&description=Socket网络编程"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Socket网络编程&body=Check out this article: http://example.com/2021/01/23/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2021/01/23/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&title=Socket网络编程"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2021/01/23/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&title=Socket网络编程"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2021/01/23/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&title=Socket网络编程"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2021/01/23/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&title=Socket网络编程"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2021/01/23/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&name=Socket网络编程&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2021/01/23/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&t=Socket网络编程"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2020-2021
    Chikie
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/projects_url">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'cactus-1';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


</body>
</html>
