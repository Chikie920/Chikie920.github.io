<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
        <!--Valine-->
        <script src="/js/Valine.min.js"></script>
    <meta name="description" content="函数6.1-函数基础 函数可以重载，即一个名字对应多个不同函数  函数定义包括：返回类型、函数名字、由0个或多个形参组成的形参列表、函数体  实参：调用函数时传入的参数，形参：自定义函数创建时的参数  为与C兼容，可用void关键字表示函数没有形参  函数的返回类型不能是数组或者函数，但能是指向它们的指针   6.1.1-局部对象 形参和函数体内定义的变量统称为局部变量，只在它所在的作用域内可见">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Primer 第六章 函数">
<meta property="og:url" content="http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/index.html">
<meta property="og:site_name" content="Chikie">
<meta property="og:description" content="函数6.1-函数基础 函数可以重载，即一个名字对应多个不同函数  函数定义包括：返回类型、函数名字、由0个或多个形参组成的形参列表、函数体  实参：调用函数时传入的参数，形参：自定义函数创建时的参数  为与C兼容，可用void关键字表示函数没有形参  函数的返回类型不能是数组或者函数，但能是指向它们的指针   6.1.1-局部对象 形参和函数体内定义的变量统称为局部变量，只在它所在的作用域内可见">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/6.2.6.png">
<meta property="article:published_time" content="2021-04-09T10:47:48.000Z">
<meta property="article:modified_time" content="2021-04-09T11:16:36.430Z">
<meta property="article:author" content="Chikie">
<meta property="article:tag" content="Cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/6.2.6.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>C++ Primer 第六章 函数</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/projects_url">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2021/04/09/C++Primer-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2021/04/09/C++Primer-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%AF%AD%E5%8F%A5/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/&text=C++ Primer 第六章 函数"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/&title=C++ Primer 第六章 函数"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/&is_video=false&description=C++ Primer 第六章 函数"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=C++ Primer 第六章 函数&body=Check out this article: http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/&title=C++ Primer 第六章 函数"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/&title=C++ Primer 第六章 函数"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/&title=C++ Primer 第六章 函数"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/&title=C++ Primer 第六章 函数"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/&name=C++ Primer 第六章 函数&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/&t=C++ Primer 第六章 函数"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">6.1-函数基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-%E5%B1%80%E9%83%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.1.</span> <span class="toc-text">6.1.1-局部对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">1.1.2.</span> <span class="toc-text">6.1.2-函数声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91"><span class="toc-number">1.1.3.</span> <span class="toc-text">6.1.3-分离式编译</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">1.2.</span> <span class="toc-text">6.2-参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E4%BC%A0%E5%80%BC%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">6.2.1-传值参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-%E4%BC%A0%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">6.2.2-传引用参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-3-const%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82"><span class="toc-number">1.2.3.</span> <span class="toc-text">6.2.3-const形参和实参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-4-%E6%95%B0%E7%BB%84%E5%BD%A2%E5%8F%82"><span class="toc-number">1.2.4.</span> <span class="toc-text">6.2.4-数组形参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-5-main-%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9"><span class="toc-number">1.2.5.</span> <span class="toc-text">6.2.5-main:处理命令行选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-6-%E5%90%AB%E5%8F%AF%E5%8F%98%E5%BD%A2%E5%8F%82%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.6.</span> <span class="toc-text">6.2.6-含可变形参的函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%92%8Creturn%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.</span> <span class="toc-text">6.3-返回类型和return语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-3-%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">6.3.3-返回数组指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">1.4.</span> <span class="toc-text">6.4-函数重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-1-%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">6.4.1-重载与作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="toc-number">1.5.</span> <span class="toc-text">6.5-特殊用途语言特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-1-%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82"><span class="toc-number">1.5.1.</span> <span class="toc-text">6.5.1-默认实参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-2-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8Cconstexpr%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.2.</span> <span class="toc-text">6.5.2-内联函数和constexpr函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-3-%E8%B0%83%E8%AF%95%E5%B8%AE%E5%8A%A9"><span class="toc-number">1.5.3.</span> <span class="toc-text">6.5.3-调试帮助</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D"><span class="toc-number">1.6.</span> <span class="toc-text">6.6-函数匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-1-%E5%AE%9E%E5%8F%82%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.6.1-实参类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.7.</span> <span class="toc-text">6.7-函数指针</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        C++ Primer 第六章 函数
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Chikie</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-04-09T10:47:48.000Z" itemprop="datePublished">2021-04-09</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Cpp/" rel="tag">Cpp</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1-函数基础"></a>6.1-函数基础</h2><ul>
<li><p>函数可以<code>重载</code>，即一个名字对应多个不同函数</p>
</li>
<li><p><code>函数定义</code>包括：<code>返回类型</code>、<code>函数名字</code>、由0个或多个形参组成的<code>形参列表</code>、<code>函数体</code></p>
</li>
<li><p><strong>实参</strong>：调用函数时传入的参数，<strong>形参</strong>：自定义函数创建时的参数</p>
</li>
<li><p>为与C兼容，可用<code>void关键字</code>表示函数没有形参</p>
</li>
<li><p>函数的返回类型不能是数组或者函数，但能是指向它们的指针</p>
</li>
</ul>
<h3 id="6-1-1-局部对象"><a href="#6-1-1-局部对象" class="headerlink" title="6.1.1-局部对象"></a>6.1.1-局部对象</h3><ul>
<li><p>形参和函数体内定义的变量统称为<strong>局部变量</strong>，只在它所在的作用域内可见</p>
</li>
<li><p>局部变量是一种<strong>自动对象</strong>，当执行到包含它的块(函数)的末尾会被销毁</p>
</li>
<li><p>在局部变量前加上 <code>static</code>关键字，使局部对象变为<strong>局部静态对象</strong>，在程序执行第一次经过定义语句时初始化，直到程序终止才被销毁，在此期间它所在的函数结束运行也不会照成影响</p>
</li>
</ul>
<h3 id="6-1-2-函数声明"><a href="#6-1-2-函数声明" class="headerlink" title="6.1.2-函数声明"></a>6.1.2-函数声明</h3><ul>
<li>函数只能定义一次，但可声明多次</li>
</ul>
<h3 id="6-1-3-分离式编译"><a href="#6-1-3-分离式编译" class="headerlink" title="6.1.3-分离式编译"></a>6.1.3-分离式编译</h3><ul>
<li>C++支持分离式编译，即允许将程序分割到几个文件中，每个文件单独编译</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> CC -c factMain.cc             <span class="comment">#产生factMain.o</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> CC -c fact.cc                 <span class="comment">#产生fact.o</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> CC factMain.o fact.o -o main  <span class="comment">#将两个对象文件链接为可执行文件</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">CC为编译器名字</span></span><br></pre></td></tr></table></figure>

<ul>
<li>大多数编译器提供了分离式编译每个文件的机制，这 一过程通常会产生一个后缀名是<code>.obj</code>(Windows) 或<code>.o</code> (UNIX) 的文件</li>
</ul>
<h2 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2-参数传递"></a>6.2-参数传递</h2><ul>
<li><strong>传引用调用</strong>：当形参是引用类型时，实参和形参是一个对象</li>
<li><strong>传值调用</strong>：实参的值被拷贝给形参，形参和实参是两个独立的对象</li>
</ul>
<h3 id="6-2-1-传值参数"><a href="#6-2-1-传值参数" class="headerlink" title="6.2.1-传值参数"></a>6.2.1-传值参数</h3><ul>
<li><p>当初始化一个非引用类型的变量时，初始值被拷贝给变量，此时对变量的改变不会影响初始值</p>
</li>
<li><p>指针形参只能改变实参指针所指向的对象，而不能改变实参指针指向</p>
</li>
</ul>
<h3 id="6-2-2-传引用参数"><a href="#6-2-2-传引用参数" class="headerlink" title="6.2.2-传引用参数"></a>6.2.2-传引用参数</h3><ul>
<li><p>对于引用的操作实际上是作用在引用绑定的对象上</p>
</li>
<li><p>如果函数无须改变引用形参的值，最好将其声明为<strong>常量引用</strong></p>
</li>
</ul>
<h3 id="6-2-3-const形参和实参"><a href="#6-2-3-const形参和实参" class="headerlink" title="6.2.3-const形参和实参"></a>6.2.3-const形参和实参</h3><ul>
<li><p>顶层const作用于对象本身</p>
</li>
<li><p>使用实参初始化形参时会忽略顶层const，当形参有顶层const时，传const对象或非const对象都可以</p>
</li>
<li><p><strong>函数重载</strong>：在C++语言中，允许我们定义若干具有相同名字的函数，不过前提是不同函数的形参列表应该有明显的区别</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面两个函数可接受相同参数，故是相同函数，不可重载</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;&#125; <span class="comment">//错，重复定义</span></span><br></pre></td></tr></table></figure>



<h3 id="6-2-4-数组形参"><a href="#6-2-4-数组形参" class="headerlink" title="6.2.4-数组形参"></a>6.2.4-数组形参</h3><p>数组会自动转换成指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下3个函数等价，形参类型都是const int *</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> [])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> [<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>



<p><strong>数组引用形参</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])</span></span>&#123; <span class="comment">//形参是数组的引用，数组不转指针，实参大小也必须符合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> elem:arr)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;elem&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>传递多维数组</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下两定义等价</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (*matrix)[<span class="number">10</span>], <span class="keyword">int</span> rowSize)</span></span>&#123;&#125;    <span class="comment">//指针形式传入二维数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">10</span>], <span class="keyword">int</span> rowSize)</span></span>&#123;&#125;     <span class="comment">//数组形式传入二维数组，第一个维度可省略</span></span><br></pre></td></tr></table></figure>



<h3 id="6-2-5-main-处理命令行选项"><a href="#6-2-5-main-处理命令行选项" class="headerlink" title="6.2.5-main:处理命令行选项"></a>6.2.5-main:处理命令行选项</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>argv</code>是一个数组，其元素是指向C风格字符串的指针。<code>argc</code>表示数组长度</li>
</ul>
<p><strong>向main传递参数</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> prog -d -o ofile data //假定main函数位于可执行文件prog下</span></span><br></pre></td></tr></table></figure>



<h3 id="6-2-6-含可变形参的函数"><a href="#6-2-6-含可变形参的函数" class="headerlink" title="6.2.6-含可变形参的函数"></a>6.2.6-含可变形参的函数</h3><ul>
<li><p>有时候无法预知函数会被传入多少个实参，此时用<strong>可变形参</strong></p>
</li>
<li><p>C++11，如果所有的实参类型相同，可以传递一个名为<code>initializer_list</code>的标准库类型</p>
</li>
</ul>
<p><strong>initializer_list形参</strong></p>
<p>如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用<strong>initializer_list</strong>类型的形参</p>
<p><img src="/images/6.2.6.png" alt="6.2.6"></p>
<ul>
<li>和vector一样initializer_list也是一种模板类型，定义其对象时必须指明元素类型</li>
<li>initializer_list对象中的元素永远是<strong>常量</strong>，无法改变</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; i;</span><br></pre></td></tr></table></figure>



<p><strong>省略符形参</strong></p>
<ul>
<li>省略符形参只能出现在形参列表的最后，省略符形参对应的实参无需类型检查</li>
</ul>
<h2 id="6-3-返回类型和return语句"><a href="#6-3-返回类型和return语句" class="headerlink" title="6.3-返回类型和return语句"></a>6.3-返回类型和return语句</h2><ul>
<li><p> 返回值为void的函数无需<code>return</code>语句，函数末尾会隐式执行<code>return;</code></p>
</li>
<li><p> 有返回值的函数必须通过显式的return返回，返回类型必须匹配</p>
</li>
<li><p> 函数返回值的方式和初始化变量、形参一样：返回的值用于初始化调用点的一个临时量，该临时量是调用表达式的结果</p>
</li>
<li><p> <strong>不可返回局部对象的引用或指针</strong>：函数终止意味着局部变量的引用将指向不再有效的内存区域，内存将会被销毁</p>
</li>
</ul>
<p><strong>列表初始化返回值</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(expected.empty())        <span class="keyword">return</span> &#123;&#125;;                              <span class="comment">//返回vector被值初始化</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(expected==actual)   <span class="keyword">return</span> &#123;<span class="string">&quot;functionX&quot;</span>,<span class="string">&quot;OK&quot;</span>&#125;;              <span class="comment">//返回vector被列表初始化</span></span><br><span class="line">    <span class="keyword">else</span>                        <span class="keyword">return</span> &#123;<span class="string">&quot;functionX&quot;</span>,expected,actual&#125;;   <span class="comment">//返回vector被列表初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>主函数main的返回值</strong></p>
<ul>
<li><p>我们允许main函数没有return语句直接结束。如果控制到达了main函 数的结尾处而且没有return语句，编译器将隐式地插入一条返回0的return语句</p>
</li>
<li><p>main函数的返回值可以看做是状态指示器。返回0表 示执行成功，返回其他值表示执行失败，其中非0值的具体含义依机器而定</p>
</li>
<li><p><code>cstdlib</code>头文件定义了两个须处即变址，我们可以使用这两个变量分别表示成功与失败</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(some_failure)&#123;</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE; <span class="comment">//预处理器变量</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>递归</strong></p>
<ul>
<li><p>函数直接或间接调用它自身</p>
</li>
<li><p>main函数不能调用它自己</p>
</li>
</ul>
<h3 id="6-3-3-返回数组指针"><a href="#6-3-3-返回数组指针" class="headerlink" title="6.3.3-返回数组指针"></a>6.3.3-返回数组指针</h3><ul>
<li>使用类型别名简化数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">10</span>];   <span class="comment">//arrT等价于长度为10的整型数组，不会转指针</span></span><br><span class="line"><span class="keyword">using</span> arrT=<span class="keyword">int</span>[<span class="number">10</span>];     <span class="comment">//等价于上一行，arrT等价于长度为10的整型数组，不会转指针</span></span><br><span class="line"><span class="function">arrT *<span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>;      <span class="comment">//函数返回指向arrT的指针</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数不能传递数组，但是可以用指针或引用间接传递</li>
</ul>
<p><strong>声明一个返回数组指针的函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type (*function (parameter_list)) [dimension]</span><br><span class="line"><span class="comment">//int (*func(int i)) [10]; </span></span><br></pre></td></tr></table></figure>

<p>type表示元素的类型，dimension表示数组的大小，parameter_list为形参列表， (*function(parameter_list)）两端的括号必须存在</p>
<p><strong>使用尾置返回类型</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto func(int i) -&gt; int(*)[10]; //尾置返回声明，函数接收int型实参，返回一个指针，该指针指向大小为10的int数组</span><br><span class="line"><span class="keyword">int</span> (*func(<span class="keyword">int</span> i))[<span class="number">10</span>]; </span><br></pre></td></tr></table></figure>

<p>c++11，任何函数的定义都能仗用尾置返回， 但是这种形式对于返回类型比较复杂的函数最有效， 比如返回类型是数组的指针或者数组的引用。尾置返回类型放在形参列表后，并以<code>-&gt;</code>开头，代替原来返回类型的地方使用<code>auto</code>。</p>
<p><strong>使用decltype</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> odd[]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> even[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(odd) *arrPtr(<span class="keyword">int</span> i)&#123; <span class="comment">//推导返回类型为数组指针</span></span><br><span class="line">    <span class="keyword">return</span> (i%<span class="number">2</span>)?(&amp;odd):(&amp;even);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-4-函数重载"><a href="#6-4-函数重载" class="headerlink" title="6.4-函数重载"></a>6.4-函数重载</h2><ul>
<li><p>如果同一作用域内的几个函数名字相同但形参列表不同， 我们称之为重载函数。 </p>
</li>
<li><p>main函数不能重载</p>
</li>
<li><p>对于重载的函数来说，它们应该在形参数量或形参类型上有所不同</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account &amp;acct）； </span></span></span><br><span class="line"><span class="function"><span class="params">Record lookup(<span class="keyword">const</span> Account&amp;); <span class="comment">//省略了形参的名字</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">typedef</span> Phone Telno; </span></span></span><br><span class="line"><span class="function"><span class="params">Record lookup(<span class="keyword">const</span> Phone&amp;&#125;;</span></span></span><br><span class="line"><span class="function"><span class="params">Record lookup(<span class="keyword">const</span> Telno&amp;&#125;; <span class="comment">// Telno和Phone的类型相同</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">//以上函数都不能重载</span></span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>顶层const不影响传入函数的对象</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone *)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone * <span class="keyword">const</span>)</span></span>;</span><br><span class="line"><span class="comment">//顶层cosnt，不能重载</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone *)</span></span>; <span class="comment">//可以重载</span></span><br></pre></td></tr></table></figure>



<p><strong>const_cast和重载</strong></p>
<p><strong>调用重载的函数</strong></p>
<ul>
<li>找到最佳匹配的函数</li>
<li>找不到任何函数与实参匹配，无匹配错误</li>
<li>匹配到多于一个函数，但每一个都不是最佳，<strong>二义性</strong>调用错误</li>
</ul>
<h3 id="6-4-1-重载与作用域"><a href="#6-4-1-重载与作用域" class="headerlink" title="6.4.1-重载与作用域"></a>6.4.1-重载与作用域</h3><p> 如果我们在内层作用域中声明名字， 它将隐藏外层作用域中声明的同名实体。 在不同的作用域中无法重载函数名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">string</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">string</span> print = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">    print(<span class="string">&quot;hello&quot;</span>); <span class="comment">//错误，隐藏了print函数，无法调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>C++中，名字查找发生在类型检查之前</li>
</ul>
<h2 id="6-5-特殊用途语言特性"><a href="#6-5-特殊用途语言特性" class="headerlink" title="6.5-特殊用途语言特性"></a>6.5-特殊用途语言特性</h2><h3 id="6-5-1-默认实参"><a href="#6-5-1-默认实参" class="headerlink" title="6.5.1-默认实参"></a>6.5.1-默认实参</h3><ul>
<li>函数调用时，可以不输入实参，而使用默认的值</li>
<li>如果我们想使用默认实参，只要在调用函数的时候省略该实参就可以了</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string screen(sz ht = 24, sz wid =80, char background = &#x27;&#x27;); //函数声明</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> widow;</span><br><span class="line">widow = screen(); <span class="comment">//默认实参</span></span><br><span class="line">widow = screen(<span class="number">66</span>); <span class="comment">//ht = 66</span></span><br><span class="line">widow = screen(<span class="number">66</span>, <span class="number">80</span>); <span class="comment">//ht = 66 wid = 80</span></span><br><span class="line">widow = screen( , , <span class="string">&#x27;#&#x27;</span>); <span class="comment">//错误，只能省略尾部实参</span></span><br></pre></td></tr></table></figure>

<ul>
<li>我们为每一个形参都提供了默认实参，默认实参作为形参的初始值出现在形参列表中</li>
</ul>
<p><strong>默认实参的声明</strong></p>
<ul>
<li>在给定作用域中一个形参只能被赋予一次默认实参</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string screen(sz, sz, char background = &#x27;&#x27;);</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz, sz, <span class="keyword">char</span> background = <span class="string">&#x27;*&#x27;</span>)</span></span>; <span class="comment">//错误</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz ht = <span class="number">60</span>, sz wid = <span class="number">80</span>, <span class="keyword">char</span>)</span></span>; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>



<p><strong>默认实参初始值</strong></p>
<ul>
<li>局部变量不可作为默认实参</li>
<li>默认实参的名字在声明作用域中解析，但求值发生在调用时</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sz wd=<span class="number">80</span>;</span><br><span class="line"><span class="keyword">char</span> def=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="function">sz <span class="title">ht</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz=ht(), sz=wd, <span class="keyword">char</span>=def)</span></span>; <span class="comment">//声明函数，带有默认实参</span></span><br><span class="line"><span class="built_in">string</span> window=screen(); <span class="comment">//screen(ht(),80,&#x27; &#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    def=<span class="string">&#x27;*&#x27;</span>;            <span class="comment">//def变量仍是外部的</span></span><br><span class="line">    sz wd=<span class="number">100</span>;          <span class="comment">//内部重新定义了wd变量</span></span><br><span class="line">    window=screen();    <span class="comment">//默认实参的名字在外部解析，故为screen(ht(),80,&#x27;*&#x27;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-5-2-内联函数和constexpr函数"><a href="#6-5-2-内联函数和constexpr函数" class="headerlink" title="6.5.2-内联函数和constexpr函数"></a>6.5.2-内联函数和constexpr函数</h3><ul>
<li><p>内联函数可避免函数调用的开销，作用是展开函数</p>
</li>
<li><p>在函数返回类型前加上关键字<strong>inline</strong>即可将函数声明为内联函数</p>
</li>
<li><p>内联说明只是向编译器发出的请求，编译器可将其忽略</p>
</li>
<li><p>内联适合用规模小、流程直接、调用频繁的函数。很多编译器不支持内联递归函数</p>
</li>
</ul>
<p><strong>constexpr函数</strong></p>
<ul>
<li><p>能用于常量表达式的函数的函数，定义constexpr函数的方法与其他函数类似， 不过要遵循几项约定： 函数的返回<br>类型及所有形参的 类型都得是字面值类型， 而且函数体中必须有且只有一条return语句</p>
</li>
<li><p>constexpr函数被隐式地指定为内联函数</p>
</li>
<li><p>我们允许constexpr函数返回值非常量</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">new_sz</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;                         <span class="comment">//返回常量表达式</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> <span class="title">scale</span><span class="params">(<span class="keyword">size_t</span> cnt)</span> </span>&#123;<span class="keyword">return</span> new_sz()*cnt;&#125;   <span class="comment">//形参非常量，返回值非常量</span></span><br><span class="line"><span class="keyword">int</span> arr[scale(<span class="number">2</span>)];  <span class="comment">//对，scale输入常量表达式时输出即是常量表达式</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> a2[scale(i)];   <span class="comment">//错，scale输入不是常量表达式，输出也不是常量表达式</span></span><br></pre></td></tr></table></figure>

<ul>
<li>constexpr函数不一定返回常量表达式</li>
</ul>
<h3 id="6-5-3-调试帮助"><a href="#6-5-3-调试帮助" class="headerlink" title="6.5.3-调试帮助"></a>6.5.3-调试帮助</h3><p><strong>assert预处理宏(预处理变量)</strong></p>
<ul>
<li><p>assert宏使用一个表达式作为它的条件：<code>assert(expr);</code>，首先对expr求值，如果表达式为假（即0),assert输出信息并终止程序的执行。如果 表达式为真（即非0),assert什么也不做</p>
</li>
<li><p>定义在<code>cassert</code>头文件中</p>
</li>
</ul>
<p><strong>NDEBUG预处理变量</strong></p>
<ul>
<li><p>assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG， 则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查</p>
</li>
<li><p>我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> CC -D NDEBUG main.C <span class="comment"># use /D with the Microsoft compiler</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">等价于在main.c文件的一开始写＃define NDEBUG</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ia[], <span class="keyword">size_t</span> size)</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG  <span class="comment">//只有调试状态才执行中间的代码</span></span></span><br><span class="line">    <span class="built_in">cerr</span>&lt;&lt;__func__&lt;&lt;<span class="string">&quot;: array size is &quot;</span>&lt;&lt;size&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//__func__是编译器定义的一个局部静态变量用于储存函数的名字</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>预处理器定义了另外几个对调试有用的名字</strong></p>
<ul>
<li><code>__FILE__</code>存放文件名的字符串字面值</li>
<li><code>__LINE__</code>存放当前行号的整型字面值</li>
<li><code>__TIME__</code>存放文件编译时间的字符串字面值</li>
<li><code>__DATE__</code>存放文件编译日期的字符串字面值</li>
</ul>
<h2 id="6-6-函数匹配"><a href="#6-6-函数匹配" class="headerlink" title="6.6-函数匹配"></a>6.6-函数匹配</h2><ul>
<li>当几个重载的函数形参数量相等且某些形参类型可转化时，函数匹配比较困难</li>
<li><code>第一步</code>：按名字筛选。要求：1、与被调用函数同名；2、在调用点可见。这些函数称为<code>候选函数</code></li>
<li><code>第二步</code>：按实参筛选。要求：1、形参与实参数量匹配；2、形参与实参类型匹配，或实参能转换为形参。这些函数称为<code>可行函数</code>，如果没有可行函数，编译器报错：<code>无匹配函数</code></li>
<li><code>第三步</code>：选择最匹配。实参与形参类型越接近则匹配得越好，精确匹配比需要类型转换的匹配更好。</li>
<li>选择最匹配时，如果有且仅有一个函数满足以下条件，则匹配成功，否则编译器报错：二义性调用<ul>
<li>该函数每个实参的匹配都不劣于其他可行函数</li>
<li>该函数至少有一个实参的匹配优于其他可行函数</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span>,<span class="keyword">double</span>=<span class="number">3.14</span>)</span></span>;</span><br><span class="line">f(<span class="number">5.6</span>)      <span class="comment">//(double,double)精确匹配</span></span><br><span class="line">f(<span class="number">42</span>,<span class="number">2.56</span>)  <span class="comment">//第一个实参与(int,int)匹配更好，第二个实参与(double,double=3.14)匹配更好，二义性调用</span></span><br></pre></td></tr></table></figure>

<ul>
<li>调用重载函数时尽量避免强制转换。设计良好的系统中不应对实参做强制转换</li>
</ul>
<h3 id="6-6-1-实参类型转换"><a href="#6-6-1-实参类型转换" class="headerlink" title="6.6.1-实参类型转换"></a>6.6.1-实参类型转换</h3><p><strong>匹配等级排序</strong></p>
<ol>
<li>精确匹配，包括：类型相同、数组转指针、函数转指针、改变顶层const</li>
<li>通过const转换实现的匹配</li>
<li>通过类型提升实现的匹配</li>
<li>通过算术转换或指针转换实现的匹配</li>
<li>通过类类型转换实现的匹配</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整型提升</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">short</span>)</span></span>;</span><br><span class="line">ff(<span class="string">&#x27;a&#x27;</span>);        <span class="comment">//char提升为int，调用(int)</span></span><br><span class="line"><span class="comment">//算术转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">(<span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line">manip(<span class="number">3.14</span>);    <span class="comment">//浮点字面值是double，转换到long和float代价一样，二义性调用</span></span><br></pre></td></tr></table></figure>



<p><strong>函数匹配和const 实参</strong><br>如果重载函数的区别在于它们的引用类型的形参是否引用了const，或者指针类型的形参是否指向const，则当调用发生时编译器通过头参是否是常从来决定选择哪个函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account &amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account &amp;)</span></span>;</span><br><span class="line"><span class="keyword">const</span> Account a;</span><br><span class="line">Account b;</span><br><span class="line">lookup(a);      <span class="comment">//底层const只能与底层const匹配，调用(const Account &amp;)</span></span><br><span class="line">lookup(b);      <span class="comment">//底层非const优先与底层非const匹配，调用(Account &amp;)</span></span><br></pre></td></tr></table></figure>



<h2 id="6-7-函数指针"><a href="#6-7-函数指针" class="headerlink" title="6.7-函数指针"></a>6.7-函数指针</h2><ul>
<li>函数指针指向的是函数而非对象</li>
<li>函数的类型由其返回值类型和形参类型共同决定，与函数名和形参名无关</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>; <span class="comment">//类型是：bool(const string &amp;, const string &amp;)</span></span><br><span class="line"><span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;); <span class="comment">//声明指向上面的函数的指针，未初始化</span></span><br></pre></td></tr></table></figure>

<ul>
<li>pf前面有个*， 因此pf是指针；右侧是形参列表， 表示pf 指向的是函数；pf就是一个指向函数的指针， 其中该函数的参数是两个const string的引用， 返回值是bool类型</li>
<li>*pf两端的括号必不可少。 如果不写这对括号， 则pf是一个返回值为bool 指针的函数</li>
</ul>
<p><strong>使用函数指针</strong></p>
<ul>
<li>当我们把函数名作为值使用时，函数自动转为指针，我们还能直接使用指向函数的指针调用该函数， 无须提前解引用指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>; <span class="comment">//类型是：bool(const string &amp;, const string &amp;)</span></span><br><span class="line"><span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;);         <span class="comment">//声明对应类型的函数指针，未初始化</span></span><br><span class="line">pf=&amp;lengthCompare;              <span class="comment">//初始化函数指针</span></span><br><span class="line">pf=lengthCompare;               <span class="comment">//等价于上一句。因为函数名转为指针，故取地址符是可选的</span></span><br><span class="line"><span class="comment">//下面3条语句互相等价</span></span><br><span class="line"><span class="keyword">bool</span> b1=pf(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;goodbye&quot;</span>);  <span class="comment">//解引用符是可选的</span></span><br><span class="line"><span class="keyword">bool</span> b2=(*pf)(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;goodbye&quot;</span>);</span><br><span class="line"><span class="keyword">bool</span> b3=lengthCompare(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;goodbye&quot;</span>);</span><br></pre></td></tr></table></figure>



<p><strong>若定义了指向重载函数的指针，则指针类型必须与某一函数精确匹配</strong></p>
<p><strong>函数指针形参</strong></p>
<p>和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//笫三个形参是函数类型，它会自动地转换成指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;sl, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2, <span class="keyword">bool</span> pf(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;))</span></span>; <span class="comment">//等价的声明：显式地将形参定义成指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2, <span class="keyword">bool</span> (*pf) (<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动将函数lengthCompare转换成指向该函数的指针</span></span><br><span class="line">useBigger(s1, s2, lengthCompare); </span><br></pre></td></tr></table></figure>



<p><strong>指向函数的指针</strong></p>
<ul>
<li>不能将函数作为返回值，但能将函数指针作为返回值</li>
<li>函数指针作为返回值时，必须明确写成指针。返回值中的函数类型不会被自动转为指针</li>
<li>可用类型别名和尾置返回类型简化函数指针作为返回值的函数原型</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> F=<span class="keyword">int</span>(<span class="keyword">int</span>*,<span class="keyword">int</span>);              <span class="comment">//是函数类型</span></span><br><span class="line"><span class="keyword">using</span> PF=<span class="keyword">int</span>(*)(<span class="keyword">int</span>*,<span class="keyword">int</span>);          <span class="comment">//是函数指针类型</span></span><br><span class="line"><span class="keyword">int</span> (*f1(<span class="keyword">int</span>))(<span class="keyword">int</span>*,<span class="keyword">int</span>);           <span class="comment">//直接声明</span></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;                         <span class="comment">//返回指向函数的指针，等价于上一行</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;                         <span class="comment">//返回指向函数的指针，等价于上一行</span></span><br><span class="line"><span class="function">F <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;                          <span class="comment">//错，不能返回函数</span></span><br><span class="line">auto f1(int) -&gt; int(*)(int*,int);   //等价于原声明</span><br></pre></td></tr></table></figure>

<ul>
<li>auto和decltype也可用于返回函数指针的原型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>::size_type <span class="title">sumLength</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span>::size_type <span class="title">largerLength</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(sumLength) *getFcn(<span class="keyword">const</span> <span class="built_in">string</span> &amp;); <span class="comment">//返回指向上面两函数之一的指针</span></span><br></pre></td></tr></table></figure>


  </div>
</article>

    <div class="blog-post-comments">
        <div id="vcomments">
                <!--Valine-->
                <script src="/js/Valine.min.js"></script>
            <!--id disqus_thread  <noscript>Please enable JavaScript to view the comments.</noscript>-->
            <script>
                new Valine({
                    el: '#vcomments',
                    appId: 'yEI6RlVJLA4pYwjBexhwdp8j-gzGzoHsz',
                    appKey: '0oz4352SSpNVsruE6U11qzhQ',
                     // 设置贴吧表情包地址
                    emojiCDN: '//valinecdn.bili33.top/', 
                    // 表情title和图片映射
                    emojiMaps: {
                        "Tieba-New2": "Tieba-New/image_emoticon.png",
                        "Tieba-New3": "Tieba-New/image_emoticon10.png",
                        "Tieba-New4": "Tieba-New/image_emoticon100.png",
                        "Tieba-New5": "Tieba-New/image_emoticon101.png",
                        "Tieba-New6": "Tieba-New/image_emoticon102.png",
                        "Tieba-New7": "Tieba-New/image_emoticon103.png",
                        "Tieba-New8": "Tieba-New/image_emoticon104.png",
                        "Tieba-New9": "Tieba-New/image_emoticon105.png",
                        "Tieba-New10": "Tieba-New/image_emoticon106.png",
                        "Tieba-New11": "Tieba-New/image_emoticon107.png",
                        "Tieba-New12": "Tieba-New/image_emoticon108.png",
                        "Tieba-New13": "Tieba-New/image_emoticon109.png",
                        "Tieba-New14": "Tieba-New/image_emoticon11.png",
                        "Tieba-New15": "Tieba-New/image_emoticon110.png",
                        "Tieba-New16": "Tieba-New/image_emoticon111.png",
                        "Tieba-New17": "Tieba-New/image_emoticon112.png",
                        "Tieba-New18": "Tieba-New/image_emoticon113.png",
                        "Tieba-New19": "Tieba-New/image_emoticon114.png",
                        "Tieba-New20": "Tieba-New/image_emoticon115.png",
                        "Tieba-New21": "Tieba-New/image_emoticon116.png",
                        "Tieba-New22": "Tieba-New/image_emoticon117.png",
                        "Tieba-New23": "Tieba-New/image_emoticon118.png",
                        "Tieba-New24": "Tieba-New/image_emoticon119.png",
                        "Tieba-New25": "Tieba-New/image_emoticon12.png",
                        "Tieba-New26": "Tieba-New/image_emoticon120.png",
                        "Tieba-New27": "Tieba-New/image_emoticon121.png",
                        "Tieba-New28": "Tieba-New/image_emoticon122.png",
                        "Tieba-New29": "Tieba-New/image_emoticon123.png",
                        "Tieba-New30": "Tieba-New/image_emoticon124.png",
                        "Tieba-New31": "Tieba-New/image_emoticon13.png",
                        "Tieba-New32": "Tieba-New/image_emoticon14.png",
                        "Tieba-New33": "Tieba-New/image_emoticon15.png",
                        "Tieba-New34": "Tieba-New/image_emoticon16.png",
                        "Tieba-New35": "Tieba-New/image_emoticon17.png",
                        "Tieba-New36": "Tieba-New/image_emoticon18.png",
                        "Tieba-New37": "Tieba-New/image_emoticon19.png",
                        "Tieba-New38": "Tieba-New/image_emoticon2.png",
                        "Tieba-New39": "Tieba-New/image_emoticon20.png",
                        "Tieba-New40": "Tieba-New/image_emoticon21.png",
                        "Tieba-New41": "Tieba-New/image_emoticon22.png",
                        "Tieba-New42": "Tieba-New/image_emoticon23.png",
                        "Tieba-New43": "Tieba-New/image_emoticon24.png",
                        "Tieba-New44": "Tieba-New/image_emoticon25.png",
                        "Tieba-New45": "Tieba-New/image_emoticon26.png",
                        "Tieba-New46": "Tieba-New/image_emoticon27.png",
                        "Tieba-New47": "Tieba-New/image_emoticon28.png",
                        "Tieba-New48": "Tieba-New/image_emoticon29.png",
                        "Tieba-New49": "Tieba-New/image_emoticon3.png",
                        "Tieba-New50": "Tieba-New/image_emoticon30.png",
                        "Tieba-New51": "Tieba-New/image_emoticon31.png",
                        "Tieba-New52": "Tieba-New/image_emoticon32.png",
                        "Tieba-New53": "Tieba-New/image_emoticon33.png",
                        "Tieba-New54": "Tieba-New/image_emoticon34.png",
                        "Tieba-New55": "Tieba-New/image_emoticon35.png",
                        "Tieba-New56": "Tieba-New/image_emoticon36.png",
                        "Tieba-New57": "Tieba-New/image_emoticon37.png",
                        "Tieba-New58": "Tieba-New/image_emoticon38.png",
                        "Tieba-New59": "Tieba-New/image_emoticon39.png",
                        "Tieba-New60": "Tieba-New/image_emoticon4.png",
                        "Tieba-New61": "Tieba-New/image_emoticon40.png",
                        "Tieba-New62": "Tieba-New/image_emoticon41.png",
                        "Tieba-New63": "Tieba-New/image_emoticon42.png",
                        "Tieba-New64": "Tieba-New/image_emoticon43.png",
                        "Tieba-New65": "Tieba-New/image_emoticon44.png",
                        "Tieba-New66": "Tieba-New/image_emoticon45.png",
                        "Tieba-New67": "Tieba-New/image_emoticon46.png",
                        "Tieba-New68": "Tieba-New/image_emoticon47.png",
                        "Tieba-New69": "Tieba-New/image_emoticon48.png",
                        "Tieba-New70": "Tieba-New/image_emoticon49.png",
                        "Tieba-New71": "Tieba-New/image_emoticon5.png",
                        "Tieba-New72": "Tieba-New/image_emoticon50.png",
                        "Tieba-New73": "Tieba-New/image_emoticon6.png",
                        "Tieba-New74": "Tieba-New/image_emoticon66.png",
                        "Tieba-New75": "Tieba-New/image_emoticon67.png",
                        "Tieba-New76": "Tieba-New/image_emoticon68.png",
                        "Tieba-New77": "Tieba-New/image_emoticon69.png",
                        "Tieba-New78": "Tieba-New/image_emoticon7.png",
                        "Tieba-New79": "Tieba-New/image_emoticon70.png",
                        "Tieba-New80": "Tieba-New/image_emoticon71.png",
                        "Tieba-New81": "Tieba-New/image_emoticon72.png",
                        "Tieba-New82": "Tieba-New/image_emoticon73.png",
                        "Tieba-New83": "Tieba-New/image_emoticon74.png",
                        "Tieba-New84": "Tieba-New/image_emoticon75.png",
                        "Tieba-New85": "Tieba-New/image_emoticon76.png",
                        "Tieba-New86": "Tieba-New/image_emoticon77.png",
                        "Tieba-New87": "Tieba-New/image_emoticon78.png",
                        "Tieba-New88": "Tieba-New/image_emoticon79.png",
                        "Tieba-New89": "Tieba-New/image_emoticon8.png",
                        "Tieba-New90": "Tieba-New/image_emoticon80.png",
                        "Tieba-New91": "Tieba-New/image_emoticon81.png",
                        "Tieba-New92": "Tieba-New/image_emoticon82.png",
                        "Tieba-New93": "Tieba-New/image_emoticon83.png",
                        "Tieba-New94": "Tieba-New/image_emoticon84.png",
                        "Tieba-New95": "Tieba-New/image_emoticon85.png",
                        "Tieba-New96": "Tieba-New/image_emoticon86.png",
                        "Tieba-New97": "Tieba-New/image_emoticon87.png",
                        "Tieba-New98": "Tieba-New/image_emoticon88.png",
                        "Tieba-New99": "Tieba-New/image_emoticon89.png",
                        "Tieba-New100": "Tieba-New/image_emoticon9.png",
                        "Tieba-New101": "Tieba-New/image_emoticon90.png",
                        "Tieba-New102": "Tieba-New/image_emoticon91.png",
                        "Tieba-New103": "Tieba-New/image_emoticon92.png",
                        "Tieba-New104": "Tieba-New/image_emoticon93.png",
                        "Tieba-New105": "Tieba-New/image_emoticon94.png",
                        "Tieba-New106": "Tieba-New/image_emoticon95.png",
                        "Tieba-New107": "Tieba-New/image_emoticon96.png",
                        "Tieba-New108": "Tieba-New/image_emoticon97.png",
                        "Tieba-New109": "Tieba-New/image_emoticon98.png",
                        "Tieba-New110": "Tieba-New/image_emoticon99.png",
                        // ... 更多表情
                    } 
                })
            </script>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/projects_url">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">6.1-函数基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-%E5%B1%80%E9%83%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.1.</span> <span class="toc-text">6.1.1-局部对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">1.1.2.</span> <span class="toc-text">6.1.2-函数声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91"><span class="toc-number">1.1.3.</span> <span class="toc-text">6.1.3-分离式编译</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">1.2.</span> <span class="toc-text">6.2-参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E4%BC%A0%E5%80%BC%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">6.2.1-传值参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-%E4%BC%A0%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">6.2.2-传引用参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-3-const%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82"><span class="toc-number">1.2.3.</span> <span class="toc-text">6.2.3-const形参和实参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-4-%E6%95%B0%E7%BB%84%E5%BD%A2%E5%8F%82"><span class="toc-number">1.2.4.</span> <span class="toc-text">6.2.4-数组形参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-5-main-%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9"><span class="toc-number">1.2.5.</span> <span class="toc-text">6.2.5-main:处理命令行选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-6-%E5%90%AB%E5%8F%AF%E5%8F%98%E5%BD%A2%E5%8F%82%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.6.</span> <span class="toc-text">6.2.6-含可变形参的函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%92%8Creturn%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.</span> <span class="toc-text">6.3-返回类型和return语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-3-%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">6.3.3-返回数组指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">1.4.</span> <span class="toc-text">6.4-函数重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-1-%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">6.4.1-重载与作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="toc-number">1.5.</span> <span class="toc-text">6.5-特殊用途语言特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-1-%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82"><span class="toc-number">1.5.1.</span> <span class="toc-text">6.5.1-默认实参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-2-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8Cconstexpr%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.2.</span> <span class="toc-text">6.5.2-内联函数和constexpr函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-3-%E8%B0%83%E8%AF%95%E5%B8%AE%E5%8A%A9"><span class="toc-number">1.5.3.</span> <span class="toc-text">6.5.3-调试帮助</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D"><span class="toc-number">1.6.</span> <span class="toc-text">6.6-函数匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-1-%E5%AE%9E%E5%8F%82%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.6.1-实参类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.7.</span> <span class="toc-text">6.7-函数指针</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/&text=C++ Primer 第六章 函数"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/&title=C++ Primer 第六章 函数"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/&is_video=false&description=C++ Primer 第六章 函数"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=C++ Primer 第六章 函数&body=Check out this article: http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/&title=C++ Primer 第六章 函数"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/&title=C++ Primer 第六章 函数"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/&title=C++ Primer 第六章 函数"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/&title=C++ Primer 第六章 函数"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/&name=C++ Primer 第六章 函数&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/&t=C++ Primer 第六章 函数"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2020-2021
    Chikie
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/projects_url">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'cactus-1';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


</body>
</html>
