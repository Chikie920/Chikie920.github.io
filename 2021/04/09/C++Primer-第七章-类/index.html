<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
        <!--Valine-->
        <script src="/js/Valine.min.js"></script>
    <meta name="description" content="类 类的基本思想是数据抽象和封装  数据抽象是一种依赖千接口和实现分离的编程（以及设计）技术，接口包括用户所能执行的操作  类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数  封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，用户只能使用而不能访问实现部分  类要想实现数据抽象和封装，需要首先定义一个抽象数据类型   7.1-定义抽象数据类型7.1.1-设计">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Primer 第七章 类">
<meta property="og:url" content="http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/index.html">
<meta property="og:site_name" content="Chikie">
<meta property="og:description" content="类 类的基本思想是数据抽象和封装  数据抽象是一种依赖千接口和实现分离的编程（以及设计）技术，接口包括用户所能执行的操作  类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数  封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，用户只能使用而不能访问实现部分  类要想实现数据抽象和封装，需要首先定义一个抽象数据类型   7.1-定义抽象数据类型7.1.1-设计">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-04-09T10:50:30.000Z">
<meta property="article:modified_time" content="2021-04-09T11:16:45.005Z">
<meta property="article:author" content="Chikie">
<meta property="article:tag" content="Cpp">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>C++ Primer 第七章 类</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/projects_url">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2021/04/09/%E3%80%8AC++Primer%E3%80%8B%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2021/04/09/C++Primer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/&text=C++ Primer 第七章 类"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/&title=C++ Primer 第七章 类"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/&is_video=false&description=C++ Primer 第七章 类"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=C++ Primer 第七章 类&body=Check out this article: http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/&title=C++ Primer 第七章 类"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/&title=C++ Primer 第七章 类"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/&title=C++ Primer 第七章 类"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/&title=C++ Primer 第七章 类"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/&name=C++ Primer 第七章 类&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/&t=C++ Primer 第七章 类"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">7.1-定义抽象数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-%E8%AE%BE%E8%AE%A1Sales-data%E7%B1%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">7.1.1-设计Sales_data类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-2-%E5%AE%9A%E4%B9%89%E6%94%B9%E8%BF%9B%E7%9A%84Sales-data%E7%B1%BB"><span class="toc-number">1.1.2.</span> <span class="toc-text">7.1.2-定义改进的Sales_data类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-3-%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.3.</span> <span class="toc-text">7.1.3-定义类相关的非成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-4-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.4.</span> <span class="toc-text">7.1.4-构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-5-%E6%8B%B7%E8%B4%9D%E3%80%81%E8%B5%8B%E5%80%BC%E5%92%8C%E6%9E%90%E6%9E%84"><span class="toc-number">1.1.5.</span> <span class="toc-text">7.1.5-拷贝、赋值和析构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B0%81%E8%A3%85"><span class="toc-number">1.2.</span> <span class="toc-text">7.2-访问控制与封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-%E5%8F%8B%E5%85%83"><span class="toc-number">1.2.1.</span> <span class="toc-text">7.2.1-友元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">7.3-类的其他特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-1-%E7%B1%BB%E6%88%90%E5%91%98%E5%86%8D%E6%8E%A2"><span class="toc-number">1.3.1.</span> <span class="toc-text">7.3.1-类成员再探</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-2-%E8%BF%94%E5%9B%9E-this%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">7.3.2-返回*this的成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-3-%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">7.3.3-类类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-4-%E5%8F%8B%E5%85%83%E5%86%8D%E6%8E%A2"><span class="toc-number">1.3.4.</span> <span class="toc-text">7.3.4-友元再探</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.4.</span> <span class="toc-text">7.4-类的作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-1-%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE%E4%B8%8E%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">7.4.1-名字查找与类的作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%86%8D%E6%8E%A2"><span class="toc-number">1.5.</span> <span class="toc-text">7.5-构造函数再探</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%80%BC%E5%88%97%E8%A1%A8"><span class="toc-number">1.5.1.</span> <span class="toc-text">7.5.1-构造函数初始值列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-2-%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.2.</span> <span class="toc-text">7.5.2- 委托构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-3-%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.3.</span> <span class="toc-text">7.5.3-默认构造函数的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-4-%E9%9A%90%E5%BC%8F%E7%9A%84%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.5.4.</span> <span class="toc-text">7.5.4-隐式的类类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-5-%E8%81%9A%E5%90%88%E7%B1%BB"><span class="toc-number">1.5.5.</span> <span class="toc-text">7.5.5-聚合类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-6-%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F%E7%B1%BB"><span class="toc-number">1.5.6.</span> <span class="toc-text">7.5.6-字面值常量类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">1.6.</span> <span class="toc-text">7.6-类的静态成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">小结</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        C++ Primer 第七章 类
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Chikie</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-04-09T10:50:30.000Z" itemprop="datePublished">2021-04-09</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Cpp/" rel="tag">Cpp</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><ul>
<li><p>类的基本思想是<strong>数据抽象</strong>和<strong>封装</strong></p>
</li>
<li><p><strong>数据抽象</strong>是一种依赖千接口和实现分离的编程（以及设计）技术，接口包括用户所能执行的操作</p>
</li>
<li><p>类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数</p>
</li>
<li><p>封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，用户只能使用而不能访问实现部分</p>
</li>
<li><p>类要想实现数据抽象和封装，需要首先定义一个<strong>抽象数据类型</strong></p>
</li>
</ul>
<h2 id="7-1-定义抽象数据类型"><a href="#7-1-定义抽象数据类型" class="headerlink" title="7.1-定义抽象数据类型"></a>7.1-定义抽象数据类型</h2><h3 id="7-1-1-设计Sales-data类"><a href="#7-1-1-设计Sales-data类" class="headerlink" title="7.1.1-设计Sales_data类"></a>7.1.1-设计Sales_data类</h3><h3 id="7-1-2-定义改进的Sales-data类"><a href="#7-1-2-定义改进的Sales-data类" class="headerlink" title="7.1.2-定义改进的Sales_data类"></a>7.1.2-定义改进的Sales_data类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;&#125;;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> avg_price() <span class="keyword">const</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//以上都为类的成员函数声明</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo; </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> units_sold = O; </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">double</span> revenue <span class="number">0.0</span>; </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//数据成员</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">// 以下为Sales_data的接口组成部分的非成员函数声明</span></span></span></span><br><span class="line"><span class="function"><span class="params">Sales_data add(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;&#125;;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">std</span>::ostream &amp;print(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> Sales_data&amp;&#125;;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">std</span>::istream &amp;read(<span class="built_in">std</span>::istream&amp;, Sales_data&amp;&#125;;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>定义在类内部的函数是隐式的inline函数</p>
</li>
<li><p><strong>成员函数</strong>的<strong>声明必须在类的内部</strong>，它的定义既可以在内部也可以在外部</p>
</li>
<li><p>所有成员都必须在类的内部声明，但是成员函数体可以定义在类内也可以定义在类外</p>
</li>
<li><p>组成接口的非成员函数其声明和定义都在类外</p>
</li>
</ul>
<p><strong>引入this</strong></p>
<p><code>total.isbn();</code></p>
<p>使用点运算符 <code>.</code>来访问total对象的isbn成员</p>
<ul>
<li><p>成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象，当我们调用成员函数时，用请求该函数的对象地址初始化this指针</p>
</li>
<li><p>this 形参是隐式定义的，任何定义为this的参数或变量都是违法的，我们可以在成员函数体内部使用 this, 但没有必要</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo; &#125; </span><br><span class="line">total.isbn(); <span class="comment">//将调用对象的地址赋给this，返回total.bookNo</span></span><br></pre></td></tr></table></figure>

<ul>
<li>this是一个常量指针，我们不允许改变this中保存的地址</li>
</ul>
<p><strong>引入const成员函数</strong></p>
<ul>
<li><p>isbn函数的另一个关键之处是紧随参数列表之后的const关键字，const修改隐式this指针的类型为指向常量的指针</p>
</li>
<li><p>默认情况下，this的类型是<strong>指向</strong>类类型<strong>非常量</strong>版本的<strong>常量指针</strong>，在默认情况下我们不能把this绑定到一个常量对象上</p>
</li>
<li><p>函数的参数列表之后，紧跟在参数列表后面的const表示this是个指向常量的指针。像这样使用const的成员函数被称作常量成员函数</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Sales_data::isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;                       <span class="comment">//实际的定义</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Sales_data::isbn</span><span class="params">(<span class="keyword">const</span> Sales_data *<span class="keyword">const</span> <span class="keyword">this</span>)</span> </span>&#123; <span class="comment">//上一个对应的伪代码，因为我们不能显式地定义自己的this指针，说明const成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo;</span><br><span class="line">&#125; <span class="comment">//可以读取但不能写值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>常量对象，以及常量对象的引用或指针都只能调用常量成员函数</li>
</ul>
<p><strong>类作用域和成员函数</strong></p>
<ul>
<li><p>类本身就是一个作用域，bookNo即是定义在Sales_data内的数据成员</p>
</li>
<li><p>编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序</p>
</li>
</ul>
<p><strong>在类的外部定义成员函数</strong></p>
<ul>
<li>当我们在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配</li>
<li>类外部定义的成员的名字必须包含它所属的类名</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Sales_data::avg_price</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(units_sold)&#123;</span><br><span class="line">        <span class="keyword">return</span> revenue/units_sold;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//revenue与units_sold隐式使用了函数名前的类作用域</span></span><br></pre></td></tr></table></figure>



<p><strong>定义一个返回this对象的函数</strong></p>
<h3 id="7-1-3-定义类相关的非成员函数"><a href="#7-1-3-定义类相关的非成员函数" class="headerlink" title="7.1.3-定义类相关的非成员函数"></a>7.1.3-定义类相关的非成员函数</h3><ul>
<li><p>类的接口函数并不属于类本身</p>
</li>
<li><p>如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内</p>
</li>
<li><p>IO类(istream、ostream)是不能被拷贝的类型，只能用引用来传递</p>
</li>
</ul>
<h3 id="7-1-4-构造函数"><a href="#7-1-4-构造函数" class="headerlink" title="7.1.4-构造函数"></a>7.1.4-构造函数</h3><ul>
<li>每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程， 这些函数叫做<strong>构造函数</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_data total; <span class="comment">//total被默认初始化</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>构造函数初始化类的数据成员，只要类的对象被创建就会执行构造函数</p>
</li>
<li><p>构造函数的名字和类名相同，没有返回类型，类可以包含多个构造函数</p>
</li>
<li><p>默认构造函数无须任何实参，类默认初始化时，调用默认构造函数，它不需要任何实参</p>
</li>
<li><p>构造函数不能被声明为const，在构造函数完成初始化后对象才能获得常量属性，在构造过程中是可以写值的</p>
</li>
<li><p>如果类没有显式定义构造函数，编译器会隐式定义默认构造函数，被称为合成的默认构造函数，初始化规则</p>
</li>
</ul>
<ol>
<li>如果成员存在类内初始值，则用该值初始化</li>
<li>如果成员没有类内初始值，则用默认初始化</li>
</ol>
<p><strong>某些类不能依赖千合成的默认构造函数</strong></p>
<ol>
<li>编译器只有在发现类<strong>不包含任何构造函数</strong>的情况下才会替我们生成一个默认的构造函数，一旦我们定义了一些其他的构造函数， 那么除非我们再定义一个默认的构造函数， 否则类将没有默认构造函数</li>
<li>某些类来说， 合成的默认构造函数可能执行错误的操作，如定义在块中的内置类型或复合类型（比如数组和指针）的对象被默认<br>初始化， 则它们的值将是未定义的，含有内置类型或复合类型成员的类应该在类的内部初始化这些成员， 或者定义一个自己的默认构造函数。否则， 用户在创建类的对象时就可能得到未定义的值。</li>
<li>有的时候编译器不能为某些类合成默认的构造函数，如类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数， 那么编译器将无法初始化该成员</li>
</ol>
<p><strong>定义Sales_data的构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s): bookNo(s) &#123;&#125;</span><br><span class="line">	Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p): bookNo(s), units_sold(n), revenue(p*n) &#123;&#125;</span><br><span class="line">	Sales_data(<span class="built_in">std</span>::istream &amp;);</span><br><span class="line">	<span class="comment">//新增的构造函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;&#125;;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> avg_price() <span class="keyword">const</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//之前已有的成员函数</span></span></span></span><br><span class="line"><span class="function"><span class="params">                        </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo; </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> units_sold = O; </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">double</span> revenue <span class="number">0.0</span>; </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//数据成员</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li> <code>= default</code>，C++11新标准中， 如果我们需要默认的行为， 那么可以通过在参数列表后面写上<code>= defaut</code>来要求编译器生成构造函数</li>
</ul>
<p><strong>构造函数初始值列表</strong></p>
<ul>
<li><p>上方代码中，<code>:</code>与 <code>&#123;&#125;</code>号之间的部分为 <strong>构造函数初始值列表</strong>，为新创建的对象的一个或几个数据成员赋初值</p>
</li>
<li><p>构造函数初始值是成员名字的一个列表， 每个名字后面紧跟括号括起来的（或者在花括号内的）成员初始值。不同成员的初始化通过逗号分隔开来。</p>
</li>
<li><p>在上面的两个构造函数中函数体都是空的。这是因为这些构造函数的唯一目的就是为数据成员赋初值， 一旦没有其他任务需要执行， 函数体也就为空了</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p): bookNo(s), units_sold(<span class="number">0</span>), revenue(<span class="number">0.0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造函数不应该轻易覆盖掉类内的初始值， 除非新赋的值与原值不同</li>
</ul>
<p><strong>在类的外部定义构造函数</strong></p>
<ul>
<li><strong>构造函数没有返回类型</strong>，和其他成员函数一样，当我们在类的外部定义构造函数时， 必须指明该构造函数是哪个类的成员</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::Sales_data(<span class="built_in">std</span>::istream &amp;is)</span><br><span class="line">&#123;</span><br><span class="line">	read(is, *<span class="keyword">this</span>); <span class="comment">// read函数的作用是从is中读取一条交易信息然后存入this对象中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的构造函数没有初始值列表，但执行了函数体，所以仍能初始化</span></span><br></pre></td></tr></table></figure>



<h3 id="7-1-5-拷贝、赋值和析构"><a href="#7-1-5-拷贝、赋值和析构" class="headerlink" title="7.1.5-拷贝、赋值和析构"></a>7.1.5-拷贝、赋值和析构</h3><ul>
<li><p>对象在一些情况下会被<strong>拷贝</strong>，如初始化变量，以及以传值方式传递一个对象等</p>
</li>
<li><p>使用赋值运算符<code>=</code>时，对象会被<strong>赋值</strong></p>
</li>
<li><p>对象不存在时需要<strong>析构</strong>也就是<strong>销毁</strong></p>
</li>
<li><p>如果不手动定义拷贝、赋值、析构，编译器也会自动合成它们</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Sales_data total;</span><br><span class="line">Sales_data trans;</span><br><span class="line">total = trans;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">等效于：</span></span><br><span class="line"><span class="comment">total.bookNo = trans.bookNo;</span></span><br><span class="line"><span class="comment">total.units_sold = trans.units_sold;</span></span><br><span class="line"><span class="comment">total.revenue= trans.revenue;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>尽管编译器能替我们合成拷贝、赋值和销毁的操作，但是对于某些类，合成的版本无法正常工作。特别是当类需要分配对象之外的资源时，例如管理动态内存的类</li>
</ul>
<h2 id="7-2-访问控制与封装"><a href="#7-2-访问控制与封装" class="headerlink" title="7.2-访问控制与封装"></a>7.2-访问控制与封装</h2><ul>
<li><p><strong>封装</strong>使类的实现细节对使用者不可见</p>
</li>
<li><p><strong>访问说明符</strong>：</p>
</li>
</ul>
<ol>
<li><code>public</code>:说明符后的成员在整个程序内可被访问，public成员定义类的接口</li>
<li><code>private</code>:说明符后的成员只能在类内被访问，即private封装实现类的细节</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//再次定义新的Sales_data类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//添加访问说明符</span></span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s): bookNo(s) &#123;&#125;</span><br><span class="line">	Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p): bookNo(s), units_sold(n), revenue(p*n) &#123;&#125;</span><br><span class="line">	Sales_data(<span class="built_in">std</span>::istream &amp;);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;&#125;;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">private</span>: <span class="comment">//添加访问说明符</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> avg_price() <span class="keyword">const</span> &#123; <span class="keyword">return</span> units sold ? revenue/units sold <span class="number">0</span>; &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo; </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> units_sold = O; </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">double</span> revenue <span class="number">0.0</span>; </span></span></span><br><span class="line"><span class="function"><span class="params">&#125;;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>构造函数与部分成员函数在public之后，作为接口的一部分</li>
<li>类的数据成员和作为实现部分的函数在private之后，作为类的细节封装起来</li>
</ul>
<p><strong>使用class或struct关键字</strong></p>
<ul>
<li><code>class</code>与<code>struct</code>的默认<strong>访问权限</strong>不一样</li>
</ul>
<ol>
<li>用<code>struct</code>定义类，则定义在第一个访问说明符之前的成员默认是public</li>
<li>用<code>class</code>定义类，则定义在第一个访问说明符之前的成员默认是private</li>
</ol>
<h3 id="7-2-1-友元"><a href="#7-2-1-友元" class="headerlink" title="7.2.1-友元"></a>7.2.1-友元</h3><ul>
<li><p>由于Sales_data的数据成员是封闭的，所以接口函数无法编译，它不是类的内部成员</p>
</li>
<li><p>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元，只需要增加一条以<code>friend</code>关键字开<br>始的函数声明语句即可</p>
</li>
<li><p>友元声明必须在类的内部，但最好在类的开始或结束处集中声明</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line"><span class="comment">//为Sales_data非成员函数所作的友元声明</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;&#125;;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp;print(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> Sales_data&amp;&#125;;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">friend</span> <span class="built_in">std</span>::istream &amp;read(<span class="built_in">std</span>::istream&amp;, Sales_data&amp;&#125;;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">public</span>:</span></span></span><br><span class="line"><span class="function"><span class="params">    Sales_data() = <span class="keyword">default</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s): bookNo(s) &#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">	Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p): bookNo(s), units_sold(n), revenue(p*n) &#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">	Sales_data(<span class="built_in">std</span>::istream &amp;);</span></span></span><br><span class="line"><span class="function"><span class="params">    </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">string</span> isbn() <span class="keyword">const</span> &#123; <span class="keyword">return</span> bookNo; &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    Sales_data&amp; combine(<span class="keyword">const</span> Sales_data&amp;&#125;;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">private</span>:</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> avg_price() <span class="keyword">const</span> &#123; <span class="keyword">return</span> units sold ? revenue/units sold <span class="number">0</span>; &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo; </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> units_sold = O; </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">double</span> revenue <span class="number">0.0</span>; </span></span></span><br><span class="line"><span class="function"><span class="params">&#125;;</span></span></span><br><span class="line"><span class="function"><span class="params">                        </span></span></span><br><span class="line"><span class="function"><span class="params">Sales_data add(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;&#125;;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">std</span>::ostream &amp;print(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> Sales_data&amp;&#125;;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">std</span>::istream &amp;read(<span class="built_in">std</span>::istream&amp;, Sales_data&amp;&#125;;</span></span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>友元的声明仅仅指定了访问的权限，如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明</p>
</li>
<li><p>我们通常把友元的声明与类本身放置在同一个头文件中（类的外部）</p>
</li>
<li><p>许多编译器并未强制限定友元函数必须在使用之前在类的外部声明</p>
</li>
</ul>
<h2 id="7-3-类的其他特性"><a href="#7-3-类的其他特性" class="headerlink" title="7.3-类的其他特性"></a>7.3-类的其他特性</h2><h3 id="7-3-1-类成员再探"><a href="#7-3-1-类成员再探" class="headerlink" title="7.3.1-类成员再探"></a>7.3.1-类成员再探</h3><ul>
<li><p>如果我们提供了一个构造函数，则编译器将不会自动生成默认的构造函数，如果我们的类需要默认构造函数， 必须显式地把它声明出来使用 <code>类名() = default;</code></p>
</li>
<li><p>可在类内定义类型别名，但和其他成员一样存在访问限制，可以是 <code>pbulic</code> 或 <code>private</code></p>
</li>
</ul>
<p><strong>令成员作为内联函数</strong></p>
<ul>
<li>可以在类的内部把<code>inline</code>作为声明的一部分显式地声明成员函数，也能在类的外部用<code>inline</code>关键字修饰函数的定义</li>
<li>虽然我们无须在声明和定义的地方同时说明 <code>inline</code>，最好只在类外部定义的地方说明 <code>inline</code></li>
</ul>
<p><strong>重载成员函数</strong></p>
<ul>
<li>成员函数也可以被重载，只要函数之间在参数的数量或类型上有所区别就行</li>
</ul>
<p><strong>可变数据成员</strong></p>
<ul>
<li><strong>可变数据成员</strong>永远不会是const, 即使它是const对象的成员</li>
<li>我们可以修改类的数据成员，即使在const成员函数内也可以(const成员函数的的数据成员为常量)，只需在变量的声明中加入<code>mutable</code>关键字</li>
</ul>
<p><strong>类数据成员的初始值</strong></p>
<h3 id="7-3-2-返回-this的成员函数"><a href="#7-3-2-返回-this的成员函数" class="headerlink" title="7.3.2-返回*this的成员函数"></a>7.3.2-返回*this的成员函数</h3><ul>
<li>在成员函数中返回*this，为返回调用该成员函数的对象本身</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myScreen.move(<span class="number">4</span>, <span class="number">0</span>).<span class="built_in">set</span>(<span class="string">&#x27;#&#x27;</span>); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">等效于</span></span><br><span class="line"><span class="comment">myScreen.move(4, 0);</span></span><br><span class="line"><span class="comment">myScreen.set(&#x27;#&#x27;);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p>*<em>从const 成员函数返回</em>this**</p>
<ul>
<li>const成员函数返回*this时(常量对象)，后续操作为u发改变该对象内的成员值</li>
<li>一个const成员函数如果以引用的形式返回*this， 那么它的返回类型将是常量引用</li>
</ul>
<p><strong>基于const的重载</strong></p>
<ul>
<li>通过区分成员函数是否是const的，我们可以对其进行重载，与我们之前根据指针参数是否指向const，而重载函数的原理差不多</li>
<li>const对象上只能调用const成员函数，非const对象优先调用非const成员函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//非常量对象的版本</span></span><br><span class="line">    <span class="function">Screen &amp;<span class="title">display</span><span class="params">(ostream &amp;os)</span></span>&#123;               <span class="comment">//传入this指针和返回引用都非const</span></span><br><span class="line">        do_display(os); <span class="comment">//非const方法调用const方法，传入do_display的this指针是指向const对象</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;   <span class="comment">//返回的this指针是非const方法的形参，故指向非const对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//常量对象的版本</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> Screen &amp;<span class="title">display</span><span class="params">(ostream &amp;os)</span> <span class="keyword">const</span></span>&#123;   <span class="comment">//传入指向const的this指针，返回const引用</span></span><br><span class="line">        do_display(os);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//将底层实现的函数封装为private</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_display</span><span class="params">(ostream &amp;os)</span> <span class="keyword">const</span></span>&#123;         <span class="comment">//不改变类内容也不返回类的引用，声明为const成员函数</span></span><br><span class="line">        os&lt;&lt;contents;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="7-3-3-类类型"><a href="#7-3-3-类类型" class="headerlink" title="7.3.3-类类型"></a>7.3.3-类类型</h3><ul>
<li><p>每个类定义了唯一的类型，两个类即使成员一样也是不同的类型</p>
</li>
<li><p>我们可以把类名作为类的名字使用，C++允许直接使用类名作为类型而无需使用<code>class</code>或<code>struct</code>前缀</p>
</li>
<li><p><code>class Screen;</code> 这种方式我们成为<strong>前向声明</strong>，是一种<strong>不完全类型</strong>，没有指明类的成员，需要在使用前定义</p>
</li>
</ul>
<h3 id="7-3-4-友元再探"><a href="#7-3-4-友元再探" class="headerlink" title="7.3.4-友元再探"></a>7.3.4-友元再探</h3><ul>
<li><strong>友元类</strong>，将类指明为友元，这样类中所有成员函数都可以访问到另一个类的所有成员了</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每个类负责控制自己的友元类或友元函数</li>
</ul>
<p><strong>令成员函数作为友元</strong></p>
<ul>
<li>只为特定成员函数提供访问权限</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Screenindex)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Window_mgr::clear</span><span class="params">(Screenindex)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>函数重载和友元</strong></p>
<ul>
<li>尽管重载函数的名字相同， 但它们仍然是不同的函数。如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明</li>
</ul>
<p><strong>友元声明和作用域</strong></p>
<ul>
<li><code>类</code>和<code>非成员函数</code>的声明并不需要在友元声明之前。当一个名字第一次出现在友元声明中时，隐式假定该名字在当前作用域中可见。但友元不一定真的要声明在当前作用域中。</li>
<li>但类的成员函数的声明必须在友元声明之前（因为需要类提供作用域？）。即，如果类A的成员函数f是类B的友元，则声明顺序为：<ul>
<li>定义<code>A</code>类并在其中声明成员函数<code>f</code>，但此时不能定义。因为定义需要用到<code>B</code>的成员</li>
<li>定义<code>B</code>类并在其中声明<code>A::f</code>为友元</li>
<li>定义<code>A::f</code>，这时它可使用<code>B</code>的成员</li>
</ul>
</li>
<li>友元声明的作用是影响访问权限，它不是普通意义上的声明</li>
<li>即使友元函数在类的内部被定义了，它也必须在类外独立声明，这样才能可见</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;<span class="comment">/* 友元函数可以定义在类的内部*/</span>｝</span><br><span class="line">X () &#123; f (); &#125; <span class="comment">//错误：f还没有被声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125; ;</span><br><span class="line">荨</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> f();&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::h</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> f ();&#125;</span><br><span class="line"><span class="comment">//错误： f还没有被声明</span></span><br><span class="line"><span class="comment">//声明那个定义在X中的函数</span></span><br><span class="line"><span class="comment">//正确：现在f的声明在作用域中了</span></span><br></pre></td></tr></table></figure>



<h2 id="7-4-类的作用域"><a href="#7-4-类的作用域" class="headerlink" title="7.4-类的作用域"></a>7.4-类的作用域</h2><ul>
<li><p>一个类就是一个作用域</p>
</li>
<li><p>在类的外部成员名字都被隐藏起来了，一旦遇到了类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数<br>列表和函数体</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在类的外部定义成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Window_mgr::clear</span><span class="params">(Screenindex i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Screen &amp;s = screens[i];</span><br><span class="line">	s.contents = <span class="built_in">string</span>(s.height * s.width, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数定义块内的所有成员都被隐式指定在了相应类的作用域内</span></span><br></pre></td></tr></table></figure>

<ul>
<li>类外定义成员函数时，返回类型在类名之前，故不在类的作用域中，若需用到类中的类型需手动指定</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Window_mgr::ScreenIndex <span class="title">Window_mgr::addScreen</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-4-1-名字查找与类的作用域"><a href="#7-4-1-名字查找与类的作用域" class="headerlink" title="7.4.1-名字查找与类的作用域"></a>7.4.1-名字查找与类的作用域</h3><ul>
<li><p>名字查找的过程：</p>
<ul>
<li>在名字所在的块中寻找声明，只考虑在使用处之前的声明</li>
<li>如果没找到，继续查找外层作用域</li>
<li>如果最终没找到声明，报错</li>
</ul>
</li>
<li><p>类的定义过程：</p>
<ul>
<li>编译成员的声明</li>
<li>直到类全部可见后才编译函数体</li>
</ul>
</li>
<li><p><strong>编译器处理完类中的全部声明后才会处理成员函数的定义</strong></p>
</li>
<li><p>一般来说，内层作用域中能重新定义外层作用域的别名，但在类中不行</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> Money;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">double</span> Money; <span class="comment">//即使定义别名与外层一致，仍是错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后</p>
</li>
<li><p>成员函数中使用的名字查找过程：</p>
<ul>
<li>在成员函数内部查找，只考虑使用前的声明</li>
<li>若成员函数内没找到，在类内继续查找，类的所有成员都被考虑</li>
<li>若类内没找到，则在成员函数定义之前（只看该函数定义的位置，与类定义的位置无关）的作用域内查找</li>
</ul>
</li>
<li><p>不建议用其他成员的名字作为成员函数的形参，因为在函数体内会屏蔽外面的同名实体（包括类的成员）。这时可手动指定作用域</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Screen::dummy_fcn</span><span class="params">(pos height)</span></span>&#123;</span><br><span class="line">     cursor= width*height；</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    最先在该成员函数内查找height，在函数形参列表中找到</span></span><br><span class="line"><span class="comment">    类Screen的成员height被形参屏蔽</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    cursor=width*<span class="keyword">this</span>-&gt;height;      <span class="comment">//指定该对象中的height成员</span></span><br><span class="line">    cursor=width*Screen::height;    <span class="comment">//等价于上一句，指定该类作用域中的height</span></span><br><span class="line">    cursor=width*::height;          <span class="comment">//指定全局作用域中的height</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-5-构造函数再探"><a href="#7-5-构造函数再探" class="headerlink" title="7.5-构造函数再探"></a>7.5-构造函数再探</h2><h3 id="7-5-1-构造函数初始值列表"><a href="#7-5-1-构造函数初始值列表" class="headerlink" title="7.5.1-构造函数初始值列表"></a>7.5.1-构造函数初始值列表</h3><ul>
<li><p>如果未在构造函数初值列表中显式初始化成员，且未提供类内初始值，则该成员在执行构造函数体之前被<strong>默认初始化</strong></p>
</li>
<li><p>在构造函数初值列表中显式初始化成员相当于<strong>初始化</strong>，在构造函数体内赋值相当于<strong>赋值</strong></p>
</li>
<li><p>构造函数的初始值有时必不可少，如果成员是const或者是引用的话，必须将其初始化，当成员属于某种类类型且该类没有定<br>义默认构造函数时， 也必须将这个成员初始化</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstRef</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ConstRef(<span class="keyword">int</span> ii);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> ci;</span><br><span class="line">	<span class="keyword">int</span> &amp;ri;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ci与ri必须被初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">ConstRef::ConstRef(<span class="keyword">int</span> ii)</span><br><span class="line">&#123;</span><br><span class="line">i = ii;</span><br><span class="line">ci = ii; <span class="comment">//给const赋值</span></span><br><span class="line">ri = i; <span class="comment">//ri未被初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConstRef::ConstRef(<span class="keyword">int</span> ii) : i(ii), ci(ii), ri(i)&#123;&#125;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>



<p><strong>成员初始化的顺序</strong></p>
<ul>
<li>成员的初始化顺序与它们在类定义中的出现顺序一致： 第一个成员先被初始化， 然后第二个， 以此类推</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    X(<span class="keyword">int</span> val): j(val), i(j) &#123;&#125;     <span class="comment">//未定义行为</span></span><br><span class="line">    X(<span class="keyword">int</span> val): j(val), i(val) &#123;&#125;   <span class="comment">//正确行为</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译器会先初始化i再是j</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。</p>
</li>
<li><p>如果一个构造函数为所有参数都提供了默认实参， 则它实际上也定义了默认构造函数</p>
</li>
</ul>
<h3 id="7-5-2-委托构造函数"><a href="#7-5-2-委托构造函数" class="headerlink" title="7.5.2- 委托构造函数"></a>7.5.2- 委托构造函数</h3><ul>
<li><p>一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程</p>
</li>
<li><p>一个委托构造函数也有一个成员初始值的列表和一个函数体，在委托构造函数内， 成员初始值列表只有一个唯一的入口，就是类名本身。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sales_data(<span class="built_in">string</span> s, <span class="keyword">unsigned</span> cnt, <span class="keyword">double</span> price): bookNo(s), units_sold(cnt), revenue(cnt*price) &#123;&#125;</span><br><span class="line">    Sales_data(): Sales_data(<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="number">0</span>) &#123;&#125; <span class="comment">//委托Sales_data(string s, unsigned cnt, double price)</span></span><br><span class="line">    Sales_data(<span class="built_in">string</span> s): Sales_data(s,<span class="number">0</span>,<span class="number">0</span>) &#123;&#125; <span class="comment">//委托Sales_data(string s, unsigned cnt, double price)</span></span><br><span class="line">    Sales_data(istream &amp;is): Sales_data() &#123;read(is,*<span class="keyword">this</span>);&#125; <span class="comment">//委托Sales_data()</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="7-5-3-默认构造函数的作用"><a href="#7-5-3-默认构造函数的作用" class="headerlink" title="7.5.3-默认构造函数的作用"></a>7.5.3-默认构造函数的作用</h3><ul>
<li><p>当对象被默认初始化时执行默认构造函数</p>
</li>
<li><p><strong>默认初始化</strong>发生的情形:</p>
<ul>
<li>块定义域内不使用初始值就定义一个非静态变量/数组</li>
<li>类本身含有类类型成员并使用合成的默认构造函数</li>
<li>类类型成员没有在构造函数初值列表中显式初始化</li>
</ul>
</li>
<li><p><strong>值初始化</strong>发生的情形:</p>
<ul>
<li>数组初始化时提供的初始值小于数组大小</li>
<li>不使用初始值定义一个局部静态变量</li>
<li>书写<code>T()</code>的表达式进行显式值初始化，例如vector仅指定元素数量时</li>
</ul>
</li>
<li><p>如果定义了其他构造函数， 那么最好也提供一个默认构造函数</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">obj</span><span class="params">()</span></span>;   <span class="comment">//错，定义的是函数而非类</span></span><br><span class="line">Sales_data obj;     <span class="comment">//对，默认初始化，调用默认构造函数</span></span><br></pre></td></tr></table></figure>



<h3 id="7-5-4-隐式的类类型转换"><a href="#7-5-4-隐式的类类型转换" class="headerlink" title="7.5.4-隐式的类类型转换"></a>7.5.4-隐式的类类型转换</h3><ul>
<li>如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制， 有时我们把这种构造函数称作<strong>转换构造函数</strong></li>
<li>编译器只能执行一步隐式类型转换</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> null_book=<span class="string">&quot;9-999-99999-9&quot;</span>;</span><br><span class="line">item.combine(null_book);<span class="comment">//隐式创建了一个Sales_data对象</span></span><br><span class="line">item.combine(<span class="string">&quot;9-999-99999-9&quot;</span>);<span class="comment">//错误，需要两步转换，先把字符串常量转换为string对象才行</span></span><br><span class="line">item.combine(<span class="built_in">string</span>(<span class="string">&quot;9-999-99999-9&quot;</span>)); <span class="comment">//正确</span></span><br><span class="line">item.combine(Sales_data(<span class="string">&quot;9-999-99999-9&quot;</span>)); <span class="comment">//正确</span></span><br><span class="line">item.combine(<span class="built_in">cin</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">了接受一个istream 的Sales_data构造函数。该构造函数通过读取标准输入创建了一个（临时的） Sales_data</span></span><br><span class="line"><span class="comment">对象，随后将得到的对象传递给combine</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>可将构造函数声明前加上<code>explicit</code>以禁止发生隐式类型转换，但仍可用<code>static_cast</code>做显式类型转换，此时会创建一个临时量</p>
</li>
<li><p>关键字<code>explicit</code>只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换， 所以无须将这些构造函数指定为explict的</p>
</li>
<li><p>只能在类内声明构造函数时使用<code>explicit</code>关键字， 在<strong>类外部定义时不应重复使用关键字</strong></p>
</li>
<li><p>explicit 构造函数只能用于直接初始化</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sales_data()=<span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p):</span><br><span class="line">                bookNo(s), units_sold(n), revenue(p*n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;S)</span>: <span class="title">bookNo</span><span class="params">(s)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(istream &amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data <span class="title">item1</span><span class="params">(null_book)</span></span>;</span><br><span class="line">Sales_data item2 = null_book;<span class="comment">//错误，拷贝初始化</span></span><br></pre></td></tr></table></figure>

<ul>
<li>接受单一参数<code>const char *</code>的string构造函数不是explicit</li>
<li>接受单一容量参数的vector构造函数是explicit</li>
</ul>
<h3 id="7-5-5-聚合类"><a href="#7-5-5-聚合类" class="headerlink" title="7.5.5-聚合类"></a>7.5.5-聚合类</h3><ul>
<li><p><strong>聚合类</strong>使得用户可以直接访问其成员，并且具有特殊的初始化语法形式</p>
</li>
<li><p><strong>聚合类</strong>：满足以下条件：</p>
</li>
</ul>
<ol>
<li>所有成员都是public的</li>
<li>没有定义构造函数</li>
<li>没有类内初始值</li>
<li>没有基类和virtual函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ival;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们可以提供一个花括号括起来的成员初始值列表， 并用它<strong>初始化聚合类的数据成员</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Data vall = &#123; <span class="number">0</span>, <span class="string">&quot;Anna&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>初始值的顺序必须与声明的顺序一致</strong></p>
</li>
<li><p>像这样显式列表初始化类的对象的成员的缺点：</p>
</li>
</ul>
<ol>
<li>要求成员都public</li>
<li>将正确初始化的任务交给用户</li>
<li>修改成员时需要修改用户代码</li>
</ol>
<h3 id="7-5-6-字面值常量类"><a href="#7-5-6-字面值常量类" class="headerlink" title="7.5.6-字面值常量类"></a>7.5.6-字面值常量类</h3><ul>
<li><p>一般的字面值常量是算术类型、引用、指针，某些类也可以是字面值类型，字面值类型的类可能含有constexpr函数成员</p>
</li>
<li><p>数据成员都是字面值类型的聚合类是<strong>字面值常量类</strong>：</p>
</li>
</ul>
<ol>
<li>数据成员都是字面值类型</li>
<li>至少有一个constexpr构造函数</li>
<li>若数据成员有类内初始值，则内置类型成员的初值必须是常量表达式，类类型成员的初值必须用它自己的constexpr构造函数</li>
<li>必须用析构函数的默认定义，该成员负责销毁类的对象（析构-销毁）</li>
</ol>
<p><strong>constexpr 构造函数</strong></p>
<ul>
<li><p>虽然构造函数不能是const的，但字面值常量类的构造函数可以是constexpr的，且必须提供至少一个constexpr构造函数</p>
</li>
<li><p>constexpr构造函数可以声明成 <code>= default</code> 或删除函数的形式</p>
</li>
<li><p>constexpr 构造函数体一般来说应该是空的，通过前置constexpr声明该函数</p>
</li>
<li><p>constexpr 构造函数必须初始化所有数据成员</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个字面值常量类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Debug</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    constexpr Debug(bool b=true): hw(b), io(b), other(b) &#123;&#125;             //constexpr构造函数，仅使用初值列表</span><br><span class="line">    constexpr Debug(bool h, bool i, bool o): hw(h), io(i), other(o) &#123;&#125;  //constexpr构造函数，仅使用初值列表</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">any</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> hw||io||other;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_hw</span><span class="params">(<span class="keyword">bool</span> b)</span></span>&#123;hw=b;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_io</span><span class="params">(<span class="keyword">bool</span> b)</span></span>&#123;io=b;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_other</span><span class="params">(<span class="keyword">bool</span> b)</span></span>&#123;other=b;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> hw;    <span class="comment">//硬件错误</span></span><br><span class="line">    <span class="keyword">bool</span> io;    <span class="comment">//io错误</span></span><br><span class="line">    <span class="keyword">bool</span> other; <span class="comment">//其他错误</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Debug <span class="title">io_sub</span><span class="params">(<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>)</span></span>;   <span class="comment">//字面值常量类的对象，调试io</span></span><br><span class="line"><span class="keyword">if</span>(io_sub.any())                            <span class="comment">//等价于 if(true)</span></span><br><span class="line">    <span class="built_in">cerr</span>&lt;&lt;<span class="string">&quot;print appropriate error messages&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Debug <span class="title">prod</span><span class="params">(<span class="literal">false</span>)</span></span>;                <span class="comment">//字面值常量类的对象，无调试</span></span><br><span class="line"><span class="keyword">if</span>(prod.any())                              <span class="comment">//等价于 if(false)</span></span><br><span class="line">    <span class="built_in">cerr</span>&lt;&lt;<span class="string">&quot;print an error message&quot;</span>&lt;&lt;<span class="built_in">endl</span>;    </span><br></pre></td></tr></table></figure>



<h2 id="7-6-类的静态成员"><a href="#7-6-类的静态成员" class="headerlink" title="7.6-类的静态成员"></a>7.6-类的静态成员</h2><p>有的时候类需要它的一些成员与类本身直接相关， 而不是与类的各个对象保待关联</p>
<p><strong>声明静态成员</strong></p>
<ul>
<li><p>在成员声明前加上 <code>static</code> 关键字使其于类关联在一起，静态成员可以是<code>public</code>也可是<code>private</code>,类型可是常量、引用、指针、类类型等</p>
</li>
<li><p>类的静态成员存在于任何对象之外，任何对象中都不包含与之相关的数据，而且被所有该类的对象共享</p>
</li>
<li><p>静态成员不与任何对象绑定，故不存在<code>this指针</code>。因此既不能在函数体内使用this指针，也不能被声明为const成员函数</p>
</li>
</ul>
<p><strong>使用类的静态成员</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明静态成员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;amount+=amount*interestRate;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> interestRate;&#125; <span class="comment">//静态成员函数，它可在类内也可在类外定义</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rate</span><span class="params">(<span class="keyword">double</span>)</span></span>;                   <span class="comment">//静态成员函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> owner;</span><br><span class="line">    <span class="keyword">double</span> amount;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> interestRate;                 <span class="comment">//静态成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">initRate</span><span class="params">()</span></span>;                   <span class="comment">//静态成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用作用域运算符直接访问</span></span><br><span class="line"><span class="keyword">double</span> r;</span><br><span class="line">r = Account::rate();</span><br><span class="line"></span><br><span class="line"><span class="comment">//虽然静态成员不属于类的某个对象， 但是我们仍然可以使用类的对象、引用或者指针米访问静态成员</span></span><br><span class="line">Account ac1;</span><br><span class="line">Account *ac2=&amp;ac1;</span><br><span class="line">r=ac1.rate();</span><br><span class="line">r=ac2-&gt;rate(); </span><br></pre></td></tr></table></figure>

<ul>
<li><p>成员函数不用通过作用域运算符就能直接使用静态成员</p>
</li>
<li><p>和其他的成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时,不能重复<code>static</code>关键字</p>
</li>
<li><p>和类的所有成员一样，当我们指向类外部的静态成员函数时，必须指明成员函数所属的类名。而static关键字则只出现在类内部的声明语句中，定义语句中不能有</p>
</li>
<li><p><strong>因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的，不是由类的构造函数初始化的，我们不能在类的内部初始化静态成员，一个静态成员只能被定义一次，一旦被定义就存在于整个程序的生命周期中</strong></p>
</li>
<li><p>要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中</p>
</li>
<li><p>我们定义静态数据成员的方式和在类的外部定义成员函数差不多。我们需要指定对象的类型名，然后是类名、作用域运算符以及成员自己的名字</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义并初始化一个静态成员</span></span><br><span class="line"><span class="keyword">double</span> Account::interestRate = initRate();</span><br></pre></td></tr></table></figure>



<p><strong>静态成员的类内初始化</strong></p>
<p>通常，类的静态数据成员不应在类内初始化。特例是，可为静态数据成员提供<code>const整型</code>的<code>类内初始值</code>，且该静态数据成员必须是<code>constexpr类型</code>，初值必须是常量表达式。它们可用到任何需要常量表达式的地方</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">rate</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> interestRate;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rate</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> period=<span class="number">30</span>; <span class="comment">//常量表达式</span></span><br><span class="line">    <span class="keyword">double</span> daily_tbl[period];       <span class="comment">//可用于需要常量表达式的地方</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员</li>
</ul>
<p><strong>静态成员能用干某些场景， 而普通成员不能</strong></p>
<ul>
<li>静态数据成员的类型可以就是它所属的类类型，而非静态数据成员只能声明成它属类的指针或引用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>&#123;</span></span><br><span class="line">    <span class="keyword">static</span> Bar mem1;    <span class="comment">//对，静态成员可以是不完全类型</span></span><br><span class="line">    Bar *mem2;          <span class="comment">//对，指针可以是不完全类型</span></span><br><span class="line">    Bar mem3;           <span class="comment">//错，数据成员必须是完全类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Screen &amp;<span class="title">clear</span><span class="params">(<span class="keyword">char</span> = bkground)</span></span>; <span class="comment">//用静态成员做默认实参</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> bkground;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>非静态数据成员不能作为默认实参， 因为它的值本身属于对象的一部分， 这么做的结果是无法真正提供一个对象以便从中获取成员的值， 最终将引发错误</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>类是C++语言中最基本的特性。类允许我们为自己的应用定义新类犁， 从而使程序更加简洁且易于修改。</p>
<p>类有两项基本能力：一是数据抽象，即定义数据成员和函数成员的能力；二是封装，即保护类的成员不被随意访问的能力。通过将类的实现细节设为private, 我们就能完成类的封装。类可以将其他类或者函数设为友元，这样它们就能访回类的非公有成员了。</p>
<p>类可以定义一种特殊的成员函数：构造函数，其作用是控制初始化对象的方式。构造函数可以正载，构造函数应该使用构造函数初始值列表米初始化所有数据成员。</p>
<p>类还能定义可变或者静态成员。一个可变成员水远都不会是const, 即使在const成员函数内也能修改它的值：一个静态成员可以是函数也可以是数据， 静态成员存在于所有对象之外。</p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="vcomments">
                <!--Valine-->
                <script src="/js/Valine.min.js"></script>
            <!--id disqus_thread  <noscript>Please enable JavaScript to view the comments.</noscript>-->
            <script>
                new Valine({
                    el: '#vcomments',
                    appId: 'yEI6RlVJLA4pYwjBexhwdp8j-gzGzoHsz',
                    appKey: '0oz4352SSpNVsruE6U11qzhQ',
                     // 设置贴吧表情包地址
                    emojiCDN: '//valinecdn.bili33.top/', 
                    // 表情title和图片映射
                    emojiMaps: {
                        "Tieba-New2": "Tieba-New/image_emoticon.png",
                        "Tieba-New3": "Tieba-New/image_emoticon10.png",
                        "Tieba-New4": "Tieba-New/image_emoticon100.png",
                        "Tieba-New5": "Tieba-New/image_emoticon101.png",
                        "Tieba-New6": "Tieba-New/image_emoticon102.png",
                        "Tieba-New7": "Tieba-New/image_emoticon103.png",
                        "Tieba-New8": "Tieba-New/image_emoticon104.png",
                        "Tieba-New9": "Tieba-New/image_emoticon105.png",
                        "Tieba-New10": "Tieba-New/image_emoticon106.png",
                        "Tieba-New11": "Tieba-New/image_emoticon107.png",
                        "Tieba-New12": "Tieba-New/image_emoticon108.png",
                        "Tieba-New13": "Tieba-New/image_emoticon109.png",
                        "Tieba-New14": "Tieba-New/image_emoticon11.png",
                        "Tieba-New15": "Tieba-New/image_emoticon110.png",
                        "Tieba-New16": "Tieba-New/image_emoticon111.png",
                        "Tieba-New17": "Tieba-New/image_emoticon112.png",
                        "Tieba-New18": "Tieba-New/image_emoticon113.png",
                        "Tieba-New19": "Tieba-New/image_emoticon114.png",
                        "Tieba-New20": "Tieba-New/image_emoticon115.png",
                        "Tieba-New21": "Tieba-New/image_emoticon116.png",
                        "Tieba-New22": "Tieba-New/image_emoticon117.png",
                        "Tieba-New23": "Tieba-New/image_emoticon118.png",
                        "Tieba-New24": "Tieba-New/image_emoticon119.png",
                        "Tieba-New25": "Tieba-New/image_emoticon12.png",
                        "Tieba-New26": "Tieba-New/image_emoticon120.png",
                        "Tieba-New27": "Tieba-New/image_emoticon121.png",
                        "Tieba-New28": "Tieba-New/image_emoticon122.png",
                        "Tieba-New29": "Tieba-New/image_emoticon123.png",
                        "Tieba-New30": "Tieba-New/image_emoticon124.png",
                        "Tieba-New31": "Tieba-New/image_emoticon13.png",
                        "Tieba-New32": "Tieba-New/image_emoticon14.png",
                        "Tieba-New33": "Tieba-New/image_emoticon15.png",
                        "Tieba-New34": "Tieba-New/image_emoticon16.png",
                        "Tieba-New35": "Tieba-New/image_emoticon17.png",
                        "Tieba-New36": "Tieba-New/image_emoticon18.png",
                        "Tieba-New37": "Tieba-New/image_emoticon19.png",
                        "Tieba-New38": "Tieba-New/image_emoticon2.png",
                        "Tieba-New39": "Tieba-New/image_emoticon20.png",
                        "Tieba-New40": "Tieba-New/image_emoticon21.png",
                        "Tieba-New41": "Tieba-New/image_emoticon22.png",
                        "Tieba-New42": "Tieba-New/image_emoticon23.png",
                        "Tieba-New43": "Tieba-New/image_emoticon24.png",
                        "Tieba-New44": "Tieba-New/image_emoticon25.png",
                        "Tieba-New45": "Tieba-New/image_emoticon26.png",
                        "Tieba-New46": "Tieba-New/image_emoticon27.png",
                        "Tieba-New47": "Tieba-New/image_emoticon28.png",
                        "Tieba-New48": "Tieba-New/image_emoticon29.png",
                        "Tieba-New49": "Tieba-New/image_emoticon3.png",
                        "Tieba-New50": "Tieba-New/image_emoticon30.png",
                        "Tieba-New51": "Tieba-New/image_emoticon31.png",
                        "Tieba-New52": "Tieba-New/image_emoticon32.png",
                        "Tieba-New53": "Tieba-New/image_emoticon33.png",
                        "Tieba-New54": "Tieba-New/image_emoticon34.png",
                        "Tieba-New55": "Tieba-New/image_emoticon35.png",
                        "Tieba-New56": "Tieba-New/image_emoticon36.png",
                        "Tieba-New57": "Tieba-New/image_emoticon37.png",
                        "Tieba-New58": "Tieba-New/image_emoticon38.png",
                        "Tieba-New59": "Tieba-New/image_emoticon39.png",
                        "Tieba-New60": "Tieba-New/image_emoticon4.png",
                        "Tieba-New61": "Tieba-New/image_emoticon40.png",
                        "Tieba-New62": "Tieba-New/image_emoticon41.png",
                        "Tieba-New63": "Tieba-New/image_emoticon42.png",
                        "Tieba-New64": "Tieba-New/image_emoticon43.png",
                        "Tieba-New65": "Tieba-New/image_emoticon44.png",
                        "Tieba-New66": "Tieba-New/image_emoticon45.png",
                        "Tieba-New67": "Tieba-New/image_emoticon46.png",
                        "Tieba-New68": "Tieba-New/image_emoticon47.png",
                        "Tieba-New69": "Tieba-New/image_emoticon48.png",
                        "Tieba-New70": "Tieba-New/image_emoticon49.png",
                        "Tieba-New71": "Tieba-New/image_emoticon5.png",
                        "Tieba-New72": "Tieba-New/image_emoticon50.png",
                        "Tieba-New73": "Tieba-New/image_emoticon6.png",
                        "Tieba-New74": "Tieba-New/image_emoticon66.png",
                        "Tieba-New75": "Tieba-New/image_emoticon67.png",
                        "Tieba-New76": "Tieba-New/image_emoticon68.png",
                        "Tieba-New77": "Tieba-New/image_emoticon69.png",
                        "Tieba-New78": "Tieba-New/image_emoticon7.png",
                        "Tieba-New79": "Tieba-New/image_emoticon70.png",
                        "Tieba-New80": "Tieba-New/image_emoticon71.png",
                        "Tieba-New81": "Tieba-New/image_emoticon72.png",
                        "Tieba-New82": "Tieba-New/image_emoticon73.png",
                        "Tieba-New83": "Tieba-New/image_emoticon74.png",
                        "Tieba-New84": "Tieba-New/image_emoticon75.png",
                        "Tieba-New85": "Tieba-New/image_emoticon76.png",
                        "Tieba-New86": "Tieba-New/image_emoticon77.png",
                        "Tieba-New87": "Tieba-New/image_emoticon78.png",
                        "Tieba-New88": "Tieba-New/image_emoticon79.png",
                        "Tieba-New89": "Tieba-New/image_emoticon8.png",
                        "Tieba-New90": "Tieba-New/image_emoticon80.png",
                        "Tieba-New91": "Tieba-New/image_emoticon81.png",
                        "Tieba-New92": "Tieba-New/image_emoticon82.png",
                        "Tieba-New93": "Tieba-New/image_emoticon83.png",
                        "Tieba-New94": "Tieba-New/image_emoticon84.png",
                        "Tieba-New95": "Tieba-New/image_emoticon85.png",
                        "Tieba-New96": "Tieba-New/image_emoticon86.png",
                        "Tieba-New97": "Tieba-New/image_emoticon87.png",
                        "Tieba-New98": "Tieba-New/image_emoticon88.png",
                        "Tieba-New99": "Tieba-New/image_emoticon89.png",
                        "Tieba-New100": "Tieba-New/image_emoticon9.png",
                        "Tieba-New101": "Tieba-New/image_emoticon90.png",
                        "Tieba-New102": "Tieba-New/image_emoticon91.png",
                        "Tieba-New103": "Tieba-New/image_emoticon92.png",
                        "Tieba-New104": "Tieba-New/image_emoticon93.png",
                        "Tieba-New105": "Tieba-New/image_emoticon94.png",
                        "Tieba-New106": "Tieba-New/image_emoticon95.png",
                        "Tieba-New107": "Tieba-New/image_emoticon96.png",
                        "Tieba-New108": "Tieba-New/image_emoticon97.png",
                        "Tieba-New109": "Tieba-New/image_emoticon98.png",
                        "Tieba-New110": "Tieba-New/image_emoticon99.png",
                        // ... 更多表情
                    } 
                })
            </script>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/projects_url">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">7.1-定义抽象数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-%E8%AE%BE%E8%AE%A1Sales-data%E7%B1%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">7.1.1-设计Sales_data类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-2-%E5%AE%9A%E4%B9%89%E6%94%B9%E8%BF%9B%E7%9A%84Sales-data%E7%B1%BB"><span class="toc-number">1.1.2.</span> <span class="toc-text">7.1.2-定义改进的Sales_data类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-3-%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.3.</span> <span class="toc-text">7.1.3-定义类相关的非成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-4-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.4.</span> <span class="toc-text">7.1.4-构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-5-%E6%8B%B7%E8%B4%9D%E3%80%81%E8%B5%8B%E5%80%BC%E5%92%8C%E6%9E%90%E6%9E%84"><span class="toc-number">1.1.5.</span> <span class="toc-text">7.1.5-拷贝、赋值和析构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B0%81%E8%A3%85"><span class="toc-number">1.2.</span> <span class="toc-text">7.2-访问控制与封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-%E5%8F%8B%E5%85%83"><span class="toc-number">1.2.1.</span> <span class="toc-text">7.2.1-友元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">7.3-类的其他特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-1-%E7%B1%BB%E6%88%90%E5%91%98%E5%86%8D%E6%8E%A2"><span class="toc-number">1.3.1.</span> <span class="toc-text">7.3.1-类成员再探</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-2-%E8%BF%94%E5%9B%9E-this%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">7.3.2-返回*this的成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-3-%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">7.3.3-类类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-4-%E5%8F%8B%E5%85%83%E5%86%8D%E6%8E%A2"><span class="toc-number">1.3.4.</span> <span class="toc-text">7.3.4-友元再探</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.4.</span> <span class="toc-text">7.4-类的作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-1-%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE%E4%B8%8E%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">7.4.1-名字查找与类的作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%86%8D%E6%8E%A2"><span class="toc-number">1.5.</span> <span class="toc-text">7.5-构造函数再探</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%80%BC%E5%88%97%E8%A1%A8"><span class="toc-number">1.5.1.</span> <span class="toc-text">7.5.1-构造函数初始值列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-2-%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.2.</span> <span class="toc-text">7.5.2- 委托构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-3-%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.3.</span> <span class="toc-text">7.5.3-默认构造函数的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-4-%E9%9A%90%E5%BC%8F%E7%9A%84%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.5.4.</span> <span class="toc-text">7.5.4-隐式的类类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-5-%E8%81%9A%E5%90%88%E7%B1%BB"><span class="toc-number">1.5.5.</span> <span class="toc-text">7.5.5-聚合类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-6-%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F%E7%B1%BB"><span class="toc-number">1.5.6.</span> <span class="toc-text">7.5.6-字面值常量类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">1.6.</span> <span class="toc-text">7.6-类的静态成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">小结</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/&text=C++ Primer 第七章 类"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/&title=C++ Primer 第七章 类"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/&is_video=false&description=C++ Primer 第七章 类"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=C++ Primer 第七章 类&body=Check out this article: http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/&title=C++ Primer 第七章 类"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/&title=C++ Primer 第七章 类"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/&title=C++ Primer 第七章 类"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/&title=C++ Primer 第七章 类"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/&name=C++ Primer 第七章 类&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2021/04/09/C++Primer-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/&t=C++ Primer 第七章 类"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2020-2021
    Chikie
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/projects_url">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'cactus-1';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


</body>
</html>
